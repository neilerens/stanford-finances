{"ast":null,"code":"import _assertThisInitialized from \"/Users/neilrens/Desktop/finances2/test/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _toConsumableArray from \"/Users/neilrens/Desktop/finances2/test/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectWithoutProperties from \"/Users/neilrens/Desktop/finances2/test/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _slicedToArray from \"/Users/neilrens/Desktop/finances2/test/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _get from \"/Users/neilrens/Desktop/finances2/test/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/neilrens/Desktop/finances2/test/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/neilrens/Desktop/finances2/test/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/neilrens/Desktop/finances2/test/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"/Users/neilrens/Desktop/finances2/test/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _regeneratorRuntime from \"/Users/neilrens/Desktop/finances2/test/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/neilrens/Desktop/finances2/test/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createClass from \"/Users/neilrens/Desktop/finances2/test/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/neilrens/Desktop/finances2/test/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _objectSpread from \"/Users/neilrens/Desktop/finances2/test/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/neilrens/Desktop/finances2/test/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar _excluded = [\"children\"],\n    _excluded2 = [\"children\"],\n    _excluded3 = [\"items\", \"children\"],\n    _excluded4 = [\"items\", \"children\"];\nimport { useLayoutEffect } from 'react-layout-effect';\nimport { eachProp, is, toArray, isAnimatedString, Globals, getFluidValue, each, raf, flush, FluidValue, deprecateInterpolate, callFluidObservers, frameLoop, hasFluidValue, flushCalls, isEqual, getFluidObservers, addFluidObserver, removeFluidObserver, noop, useMemoOne, useForceUpdate, usePrev, useOnce, createInterpolator, createStringInterpolator } from '@react-spring/shared';\nexport { Globals, createInterpolator } from '@react-spring/shared';\nimport { useContext, createElement, createContext, useMemo, useRef, useState, Fragment } from 'react';\nimport { getAnimated, AnimatedValue, getPayload, AnimatedString, getAnimatedType, setAnimated } from '@react-spring/animated';\nexport * from '@react-spring/types/animated';\nexport * from '@react-spring/types/interpolation';\n\nfunction callProp(value) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return is.fun(value) ? value.apply(void 0, args) : value;\n}\n\nvar matchProp = function matchProp(value, key) {\n  return value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));\n};\n\nvar resolveProp = function resolveProp(prop, key) {\n  return is.obj(prop) ? key && prop[key] : prop;\n};\n\nvar getDefaultProp = function getDefaultProp(props, key) {\n  return props.default === true ? props[key] : props.default ? props.default[key] : void 0;\n};\n\nvar noopTransform = function noopTransform(value) {\n  return value;\n};\n\nvar getDefaultProps = function getDefaultProps(props) {\n  var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noopTransform;\n  var keys = DEFAULT_PROPS;\n\n  if (props.default && props.default !== true) {\n    props = props.default;\n    keys = Object.keys(props);\n  }\n\n  var defaults = {};\n\n  var _iterator = _createForOfIteratorHelper(keys),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      var value = transform(props[key], key);\n\n      if (!is.und(value)) {\n        defaults[key] = value;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return defaults;\n};\n\nvar DEFAULT_PROPS = [\"config\", \"onProps\", \"onStart\", \"onChange\", \"onPause\", \"onResume\", \"onRest\"];\nvar RESERVED_PROPS = {\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  loop: 1,\n  reset: 1,\n  pause: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  onProps: 1,\n  onStart: 1,\n  onChange: 1,\n  onPause: 1,\n  onResume: 1,\n  onRest: 1,\n  onResolve: 1,\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  update: 1,\n  leave: 1,\n  children: 1,\n  onDestroyed: 1,\n  keys: 1,\n  callId: 1,\n  parentId: 1\n};\n\nfunction getForwardProps(props) {\n  var forward = {};\n  var count = 0;\n  eachProp(props, function (value, prop) {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n      count++;\n    }\n  });\n\n  if (count) {\n    return forward;\n  }\n}\n\nfunction inferTo(props) {\n  var to = getForwardProps(props);\n\n  if (to) {\n    var out = {\n      to: to\n    };\n    eachProp(props, function (val, key) {\n      return key in to || (out[key] = val);\n    });\n    return out;\n  }\n\n  return _objectSpread({}, props);\n}\n\nfunction computeGoal(value) {\n  value = getFluidValue(value);\n  return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? Globals.createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\n\nfunction hasProps(props) {\n  for (var _ in props) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isAsyncTo(to) {\n  return is.fun(to) || is.arr(to) && is.obj(to[0]);\n}\n\nfunction detachRefs(ctrl, ref) {\n  var _a;\n\n  (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);\n  ref == null ? void 0 : ref.delete(ctrl);\n}\n\nfunction replaceRef(ctrl, ref) {\n  var _a;\n\n  if (ref && ctrl.ref !== ref) {\n    (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);\n    ref.add(ctrl);\n    ctrl.ref = ref;\n  }\n}\n\nfunction useChain(refs, timeSteps) {\n  var timeFrame = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e3;\n  useLayoutEffect(function () {\n    if (timeSteps) {\n      var prevDelay = 0;\n      each(refs, function (ref, i) {\n        var controllers = ref.current;\n\n        if (controllers.length) {\n          var delay = timeFrame * timeSteps[i];\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          each(controllers, function (ctrl) {\n            each(ctrl.queue, function (props) {\n              props.delay = function (key) {\n                return delay + callProp(props.delay || 0, key);\n              };\n            });\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      var p = Promise.resolve();\n      each(refs, function (ref) {\n        var controllers = ref.current;\n\n        if (controllers.length) {\n          var queues = controllers.map(function (ctrl) {\n            var q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          });\n          p = p.then(function () {\n            each(controllers, function (ctrl, i) {\n              return each(queues[i] || [], function (update) {\n                return ctrl.queue.push(update);\n              });\n            });\n            return ref.start();\n          });\n        }\n      });\n    }\n  });\n}\n\nvar config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n\nvar linear = function linear(t) {\n  return t;\n};\n\nvar defaults = _objectSpread(_objectSpread({}, config.default), {}, {\n  mass: 1,\n  damping: 1,\n  easing: linear,\n  clamp: false\n});\n\nvar AnimationConfig = /*#__PURE__*/_createClass(function AnimationConfig() {\n  _classCallCheck(this, AnimationConfig);\n\n  this.velocity = 0;\n  Object.assign(this, defaults);\n});\n\nfunction mergeConfig(config, newConfig, defaultConfig) {\n  if (defaultConfig) {\n    defaultConfig = _objectSpread({}, defaultConfig);\n    sanitizeConfig(defaultConfig, newConfig);\n    newConfig = _objectSpread(_objectSpread({}, defaultConfig), newConfig);\n  }\n\n  sanitizeConfig(config, newConfig);\n  Object.assign(config, newConfig);\n\n  for (var key in defaults) {\n    if (config[key] == null) {\n      config[key] = defaults[key];\n    }\n  }\n\n  var mass = config.mass,\n      frequency = config.frequency,\n      damping = config.damping;\n\n  if (!is.und(frequency)) {\n    if (frequency < 0.01) frequency = 0.01;\n    if (damping < 0) damping = 0;\n    config.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;\n    config.friction = 4 * Math.PI * damping * mass / frequency;\n  }\n\n  return config;\n}\n\nfunction sanitizeConfig(config, props) {\n  if (!is.und(props.decay)) {\n    config.duration = void 0;\n  } else {\n    var isTensionConfig = !is.und(props.tension) || !is.und(props.friction);\n\n    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {\n      config.duration = void 0;\n      config.decay = void 0;\n    }\n\n    if (isTensionConfig) {\n      config.frequency = void 0;\n    }\n  }\n}\n\nvar emptyArray = [];\n\nvar Animation = /*#__PURE__*/_createClass(function Animation() {\n  _classCallCheck(this, Animation);\n\n  this.changed = false;\n  this.values = emptyArray;\n  this.toValues = null;\n  this.fromValues = emptyArray;\n  this.config = new AnimationConfig();\n  this.immediate = false;\n});\n\nfunction scheduleProps(callId, _ref) {\n  var key = _ref.key,\n      props = _ref.props,\n      defaultProps = _ref.defaultProps,\n      state = _ref.state,\n      actions = _ref.actions;\n  return new Promise(function (resolve, reject) {\n    var _a;\n\n    var delay;\n    var timeout;\n    var cancel = matchProp((_a = props.cancel) != null ? _a : defaultProps == null ? void 0 : defaultProps.cancel, key);\n\n    if (cancel) {\n      onStart();\n    } else {\n      if (!is.und(props.pause)) {\n        state.paused = matchProp(props.pause, key);\n      }\n\n      var pause = defaultProps == null ? void 0 : defaultProps.pause;\n\n      if (pause !== true) {\n        pause = state.paused || matchProp(pause, key);\n      }\n\n      delay = callProp(props.delay || 0, key);\n\n      if (pause) {\n        state.resumeQueue.add(onResume);\n        actions.pause();\n      } else {\n        actions.resume();\n        onResume();\n      }\n    }\n\n    function onPause() {\n      state.resumeQueue.add(onResume);\n      state.timeouts.delete(timeout);\n      timeout.cancel();\n      delay = timeout.time - raf.now();\n    }\n\n    function onResume() {\n      if (delay > 0) {\n        timeout = raf.setTimeout(onStart, delay);\n        state.pauseQueue.add(onPause);\n        state.timeouts.add(timeout);\n      } else {\n        onStart();\n      }\n    }\n\n    function onStart() {\n      state.pauseQueue.delete(onPause);\n      state.timeouts.delete(timeout);\n\n      if (callId <= (state.cancelId || 0)) {\n        cancel = true;\n      }\n\n      try {\n        actions.start(_objectSpread(_objectSpread({}, props), {}, {\n          callId: callId,\n          cancel: cancel\n        }), resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n}\n\nvar getCombinedResult = function getCombinedResult(target, results) {\n  return results.length == 1 ? results[0] : results.some(function (result) {\n    return result.cancelled;\n  }) ? getCancelledResult(target) : results.every(function (result) {\n    return result.noop;\n  }) ? getNoopResult(target) : getFinishedResult(target, results.every(function (result) {\n    return result.finished;\n  }));\n};\n\nvar getNoopResult = function getNoopResult(target) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : target.get();\n  return {\n    value: value,\n    noop: true,\n    finished: true,\n    target: target\n  };\n};\n\nvar getFinishedResult = function getFinishedResult(target, finished) {\n  var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : target.get();\n  return {\n    value: value,\n    finished: finished,\n    target: target\n  };\n};\n\nvar getCancelledResult = function getCancelledResult(target) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : target.get();\n  return {\n    value: value,\n    cancelled: true,\n    target: target\n  };\n};\n\nfunction runAsync(to, props, state, target) {\n  var callId = props.callId,\n      parentId = props.parentId,\n      onRest = props.onRest;\n  var prevTo = state.asyncTo,\n      prevPromise = state.promise;\n\n  if (!parentId && to === prevTo && !props.reset) {\n    return prevPromise;\n  }\n\n  return state.promise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n    var defaultProps, preventBail, bail, bailPromise, bailIfEnded, animate, result, animating;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            state.asyncId = callId;\n            state.asyncTo = to;\n            defaultProps = getDefaultProps(props, function (value, key) {\n              return key === \"onRest\" ? void 0 : value;\n            });\n            bailPromise = new Promise(function (resolve, reject) {\n              return preventBail = resolve, bail = reject;\n            });\n\n            bailIfEnded = function bailIfEnded(bailSignal) {\n              var bailResult = callId <= (state.cancelId || 0) && getCancelledResult(target) || callId !== state.asyncId && getFinishedResult(target, false);\n\n              if (bailResult) {\n                bailSignal.result = bailResult;\n                bail(bailSignal);\n                throw bailSignal;\n              }\n            };\n\n            animate = function animate(arg1, arg2) {\n              var bailSignal = new BailSignal();\n              return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                var props2, result2;\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        bailIfEnded(bailSignal);\n                        props2 = is.obj(arg1) ? _objectSpread({}, arg1) : _objectSpread(_objectSpread({}, arg2), {}, {\n                          to: arg1\n                        });\n                        props2.parentId = callId;\n                        eachProp(defaultProps, function (value, key) {\n                          if (is.und(props2[key])) {\n                            props2[key] = value;\n                          }\n                        });\n                        _context.next = 6;\n                        return target.start(props2);\n\n                      case 6:\n                        result2 = _context.sent;\n                        bailIfEnded(bailSignal);\n\n                        if (!state.paused) {\n                          _context.next = 11;\n                          break;\n                        }\n\n                        _context.next = 11;\n                        return new Promise(function (resume) {\n                          state.resumeQueue.add(resume);\n                        });\n\n                      case 11:\n                        return _context.abrupt(\"return\", result2);\n\n                      case 12:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              }))();\n            };\n\n            _context3.prev = 6;\n\n            if (is.arr(to)) {\n              animating = function () {\n                var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(queue) {\n                  var _iterator2, _step2, props2;\n\n                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          _iterator2 = _createForOfIteratorHelper(queue);\n                          _context2.prev = 1;\n\n                          _iterator2.s();\n\n                        case 3:\n                          if ((_step2 = _iterator2.n()).done) {\n                            _context2.next = 9;\n                            break;\n                          }\n\n                          props2 = _step2.value;\n                          _context2.next = 7;\n                          return animate(props2);\n\n                        case 7:\n                          _context2.next = 3;\n                          break;\n\n                        case 9:\n                          _context2.next = 14;\n                          break;\n\n                        case 11:\n                          _context2.prev = 11;\n                          _context2.t0 = _context2[\"catch\"](1);\n\n                          _iterator2.e(_context2.t0);\n\n                        case 14:\n                          _context2.prev = 14;\n\n                          _iterator2.f();\n\n                          return _context2.finish(14);\n\n                        case 17:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2, null, [[1, 11, 14, 17]]);\n                }));\n\n                return function (_x) {\n                  return _ref4.apply(this, arguments);\n                };\n              }()(to);\n            } else {\n              animating = Promise.resolve(to(animate, target.stop.bind(target)));\n            }\n\n            _context3.next = 10;\n            return Promise.all([animating.then(preventBail), bailPromise]);\n\n          case 10:\n            result = getFinishedResult(target, true);\n            _context3.next = 20;\n            break;\n\n          case 13:\n            _context3.prev = 13;\n            _context3.t0 = _context3[\"catch\"](6);\n\n            if (!(_context3.t0 instanceof BailSignal)) {\n              _context3.next = 19;\n              break;\n            }\n\n            result = _context3.t0.result;\n            _context3.next = 20;\n            break;\n\n          case 19:\n            throw _context3.t0;\n\n          case 20:\n            _context3.prev = 20;\n\n            if (callId == state.asyncId) {\n              state.asyncId = parentId;\n              state.asyncTo = parentId ? prevTo : void 0;\n              state.promise = parentId ? prevPromise : void 0;\n            }\n\n            return _context3.finish(20);\n\n          case 23:\n            if (is.fun(onRest)) {\n              raf.batchedUpdates(function () {\n                onRest(result);\n              });\n            }\n\n            return _context3.abrupt(\"return\", result);\n\n          case 25:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[6, 13, 20, 23]]);\n  }))();\n}\n\nfunction stopAsync(state, cancelId) {\n  flush(state.timeouts, function (t) {\n    return t.cancel();\n  });\n  state.pauseQueue.clear();\n  state.resumeQueue.clear();\n  state.asyncId = state.asyncTo = state.promise = void 0;\n  if (cancelId) state.cancelId = cancelId;\n}\n\nvar BailSignal = /*#__PURE__*/function (_Error) {\n  _inherits(BailSignal, _Error);\n\n  var _super = _createSuper(BailSignal);\n\n  function BailSignal() {\n    _classCallCheck(this, BailSignal);\n\n    return _super.call(this, \"An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.\");\n  }\n\n  return _createClass(BailSignal);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar isFrameValue = function isFrameValue(value) {\n  return value instanceof FrameValue;\n};\n\nvar nextId = 1;\n\nvar FrameValue = /*#__PURE__*/function (_FluidValue) {\n  _inherits(FrameValue, _FluidValue);\n\n  var _super2 = _createSuper(FrameValue);\n\n  function FrameValue() {\n    var _this;\n\n    _classCallCheck(this, FrameValue);\n\n    _this = _super2.apply(this, arguments);\n    _this.id = nextId++;\n    _this._priority = 0;\n    return _this;\n  }\n\n  _createClass(FrameValue, [{\n    key: \"priority\",\n    get: function get() {\n      return this._priority;\n    },\n    set: function set(priority) {\n      if (this._priority != priority) {\n        this._priority = priority;\n\n        this._onPriorityChange(priority);\n      }\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      var node = getAnimated(this);\n      return node && node.getValue();\n    }\n  }, {\n    key: \"to\",\n    value: function to() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return Globals.to(this, args);\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate() {\n      deprecateInterpolate();\n\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return Globals.to(this, args);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.get();\n    }\n  }, {\n    key: \"observerAdded\",\n    value: function observerAdded(count) {\n      if (count == 1) this._attach();\n    }\n  }, {\n    key: \"observerRemoved\",\n    value: function observerRemoved(count) {\n      if (count == 0) this._detach();\n    }\n  }, {\n    key: \"_attach\",\n    value: function _attach() {}\n  }, {\n    key: \"_detach\",\n    value: function _detach() {}\n  }, {\n    key: \"_onChange\",\n    value: function _onChange(value) {\n      var idle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      callFluidObservers(this, {\n        type: \"change\",\n        parent: this,\n        value: value,\n        idle: idle\n      });\n    }\n  }, {\n    key: \"_onPriorityChange\",\n    value: function _onPriorityChange(priority) {\n      if (!this.idle) {\n        frameLoop.sort(this);\n      }\n\n      callFluidObservers(this, {\n        type: \"priority\",\n        parent: this,\n        priority: priority\n      });\n    }\n  }]);\n\n  return FrameValue;\n}(FluidValue);\n\nvar $P = Symbol.for(\"SpringPhase\");\nvar HAS_ANIMATED = 1;\nvar IS_ANIMATING = 2;\nvar IS_PAUSED = 4;\n\nvar hasAnimated = function hasAnimated(target) {\n  return (target[$P] & HAS_ANIMATED) > 0;\n};\n\nvar isAnimating = function isAnimating(target) {\n  return (target[$P] & IS_ANIMATING) > 0;\n};\n\nvar isPaused = function isPaused(target) {\n  return (target[$P] & IS_PAUSED) > 0;\n};\n\nvar setActiveBit = function setActiveBit(target, active) {\n  return active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;\n};\n\nvar setPausedBit = function setPausedBit(target, paused) {\n  return paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;\n};\n\nvar SpringValue = /*#__PURE__*/function (_FrameValue) {\n  _inherits(SpringValue, _FrameValue);\n\n  var _super3 = _createSuper(SpringValue);\n\n  function SpringValue(arg1, arg2) {\n    var _this2;\n\n    _classCallCheck(this, SpringValue);\n\n    _this2 = _super3.call(this);\n    _this2.animation = new Animation();\n    _this2.defaultProps = {};\n    _this2._state = {\n      paused: false,\n      pauseQueue: new Set(),\n      resumeQueue: new Set(),\n      timeouts: new Set()\n    };\n    _this2._pendingCalls = new Set();\n    _this2._lastCallId = 0;\n    _this2._lastToId = 0;\n\n    if (!is.und(arg1) || !is.und(arg2)) {\n      var props = is.obj(arg1) ? _objectSpread({}, arg1) : _objectSpread(_objectSpread({}, arg2), {}, {\n        from: arg1\n      });\n\n      if (is.und(props.default)) {\n        props.default = true;\n      }\n\n      _this2.start(props);\n    }\n\n    return _this2;\n  }\n\n  _createClass(SpringValue, [{\n    key: \"idle\",\n    get: function get() {\n      return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);\n    }\n  }, {\n    key: \"goal\",\n    get: function get() {\n      return getFluidValue(this.animation.to);\n    }\n  }, {\n    key: \"velocity\",\n    get: function get() {\n      var node = getAnimated(this);\n      return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map(function (node2) {\n        return node2.lastVelocity || 0;\n      });\n    }\n  }, {\n    key: \"hasAnimated\",\n    get: function get() {\n      return hasAnimated(this);\n    }\n  }, {\n    key: \"isAnimating\",\n    get: function get() {\n      return isAnimating(this);\n    }\n  }, {\n    key: \"isPaused\",\n    get: function get() {\n      return isPaused(this);\n    }\n  }, {\n    key: \"advance\",\n    value: function advance(dt) {\n      var _this3 = this;\n\n      var idle = true;\n      var changed = false;\n      var anim = this.animation;\n      var config = anim.config,\n          toValues = anim.toValues;\n      var payload = getPayload(anim.to);\n\n      if (!payload && hasFluidValue(anim.to)) {\n        toValues = toArray(getFluidValue(anim.to));\n      }\n\n      anim.values.forEach(function (node2, i) {\n        if (node2.done) return;\n        var to = node2.constructor == AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i];\n        var finished = anim.immediate;\n        var position = to;\n\n        if (!finished) {\n          position = node2.lastPosition;\n\n          if (config.tension <= 0) {\n            node2.done = true;\n            return;\n          }\n\n          var elapsed = node2.elapsedTime += dt;\n          var from = anim.fromValues[i];\n          var v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n          var velocity;\n\n          if (!is.und(config.duration)) {\n            var p = 1;\n\n            if (config.duration > 0) {\n              p = (config.progress || 0) + elapsed / config.duration;\n              p = p > 1 ? 1 : p < 0 ? 0 : p;\n            }\n\n            position = from + config.easing(p) * (to - from);\n            velocity = (position - node2.lastPosition) / dt;\n            finished = p == 1;\n          } else if (config.decay) {\n            var decay = config.decay === true ? 0.998 : config.decay;\n            var e = Math.exp(-(1 - decay) * elapsed);\n            position = from + v0 / (1 - decay) * (1 - e);\n            finished = Math.abs(node2.lastPosition - position) < 0.1;\n            velocity = v0 * e;\n          } else {\n            velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;\n            var precision = config.precision || (from == to ? 5e-3 : Math.min(1, Math.abs(to - from) * 1e-3));\n            var restVelocity = config.restVelocity || precision / 10;\n            var bounceFactor = config.clamp ? 0 : config.bounce;\n            var canBounce = !is.und(bounceFactor);\n            var isGrowing = from == to ? node2.v0 > 0 : from < to;\n            var isMoving;\n            var isBouncing = false;\n            var step = 1;\n            var numSteps = Math.ceil(dt / step);\n\n            for (var n = 0; n < numSteps; ++n) {\n              isMoving = Math.abs(velocity) > restVelocity;\n\n              if (!isMoving) {\n                finished = Math.abs(to - position) <= precision;\n\n                if (finished) {\n                  break;\n                }\n              }\n\n              if (canBounce) {\n                isBouncing = position == to || position > to == isGrowing;\n\n                if (isBouncing) {\n                  velocity = -velocity * bounceFactor;\n                  position = to;\n                }\n              }\n\n              var springForce = -config.tension * 1e-6 * (position - to);\n              var dampingForce = -config.friction * 1e-3 * velocity;\n              var acceleration = (springForce + dampingForce) / config.mass;\n              velocity = velocity + acceleration * step;\n              position = position + velocity * step;\n            }\n          }\n\n          node2.lastVelocity = velocity;\n\n          if (Number.isNaN(position)) {\n            console.warn(\"Got NaN while animating:\", _this3);\n            finished = true;\n          }\n        }\n\n        if (payload && !payload[i].done) {\n          finished = false;\n        }\n\n        if (finished) {\n          node2.done = true;\n        } else {\n          idle = false;\n        }\n\n        if (node2.setValue(position, config.round)) {\n          changed = true;\n        }\n      });\n      var node = getAnimated(this);\n\n      if (idle) {\n        var value = getFluidValue(anim.to);\n\n        if (node.setValue(value) || changed) {\n          this._onChange(value);\n        }\n\n        this._stop();\n      } else if (changed) {\n        this._onChange(node.getValue());\n      }\n    }\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      var _this4 = this;\n\n      raf.batchedUpdates(function () {\n        _this4._stop();\n\n        _this4._focus(value);\n\n        _this4._set(value);\n      });\n      return this;\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this._update({\n        pause: true\n      });\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      this._update({\n        pause: false\n      });\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      var _this5 = this;\n\n      if (isAnimating(this)) {\n        var _this$animation = this.animation,\n            _to = _this$animation.to,\n            _config = _this$animation.config;\n        raf.batchedUpdates(function () {\n          _this5._onStart();\n\n          if (!_config.decay) {\n            _this5._set(_to, false);\n          }\n\n          _this5._stop();\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"update\",\n    value: function update(props) {\n      var queue = this.queue || (this.queue = []);\n      queue.push(props);\n      return this;\n    }\n  }, {\n    key: \"start\",\n    value: function start(to, arg2) {\n      var _this6 = this;\n\n      var queue;\n\n      if (!is.und(to)) {\n        queue = [is.obj(to) ? to : _objectSpread(_objectSpread({}, arg2), {}, {\n          to: to\n        })];\n      } else {\n        queue = this.queue || [];\n        this.queue = [];\n      }\n\n      return Promise.all(queue.map(function (props) {\n        return _this6._update(props);\n      })).then(function (results) {\n        return getCombinedResult(_this6, results);\n      });\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(cancel) {\n      var _this7 = this;\n\n      var to = this.animation.to;\n\n      this._focus(this.get());\n\n      stopAsync(this._state, cancel && this._lastCallId);\n      raf.batchedUpdates(function () {\n        return _this7._stop(to, cancel);\n      });\n      return this;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._update({\n        reset: true\n      });\n    }\n  }, {\n    key: \"eventObserved\",\n    value: function eventObserved(event) {\n      if (event.type == \"change\") {\n        this._start();\n      } else if (event.type == \"priority\") {\n        this.priority = event.priority + 1;\n      }\n    }\n  }, {\n    key: \"_prepareNode\",\n    value: function _prepareNode(props) {\n      var key = this.key || \"\";\n      var to = props.to,\n          from = props.from;\n      to = is.obj(to) ? to[key] : to;\n\n      if (to == null || isAsyncTo(to)) {\n        to = void 0;\n      }\n\n      from = is.obj(from) ? from[key] : from;\n\n      if (from == null) {\n        from = void 0;\n      }\n\n      var range = {\n        to: to,\n        from: from\n      };\n\n      if (!hasAnimated(this)) {\n        if (props.reverse) {\n          var _ref5 = [from, to];\n          to = _ref5[0];\n          from = _ref5[1];\n        }\n\n        from = getFluidValue(from);\n\n        if (!is.und(from)) {\n          this._set(from);\n        } else if (!getAnimated(this)) {\n          this._set(to);\n        }\n      }\n\n      return range;\n    }\n  }, {\n    key: \"_update\",\n    value: function _update(_ref6, isLoop) {\n      var _this8 = this;\n\n      var props = Object.assign({}, _ref6);\n      var key = this.key,\n          defaultProps = this.defaultProps;\n      if (props.default) Object.assign(defaultProps, getDefaultProps(props, function (value, prop) {\n        return /^on/.test(prop) ? resolveProp(value, key) : value;\n      }));\n      mergeActiveFn(this, props, \"onProps\");\n      sendEvent(this, \"onProps\", props, this);\n\n      var range = this._prepareNode(props);\n\n      if (Object.isFrozen(this)) {\n        throw Error(\"Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?\");\n      }\n\n      var state = this._state;\n      return scheduleProps(++this._lastCallId, {\n        key: key,\n        props: props,\n        defaultProps: defaultProps,\n        state: state,\n        actions: {\n          pause: function pause() {\n            if (!isPaused(_this8)) {\n              setPausedBit(_this8, true);\n              flushCalls(state.pauseQueue);\n              sendEvent(_this8, \"onPause\", _this8);\n            }\n          },\n          resume: function resume() {\n            if (isPaused(_this8)) {\n              setPausedBit(_this8, false);\n\n              if (isAnimating(_this8)) {\n                _this8._resume();\n              }\n\n              flushCalls(state.resumeQueue);\n              sendEvent(_this8, \"onResume\", _this8);\n            }\n          },\n          start: this._merge.bind(this, range)\n        }\n      }).then(function (result) {\n        if (props.loop && result.finished && !(isLoop && result.noop)) {\n          var nextProps = createLoopUpdate(props);\n\n          if (nextProps) {\n            return _this8._update(nextProps, true);\n          }\n        }\n\n        return result;\n      });\n    }\n  }, {\n    key: \"_merge\",\n    value: function _merge(range, props, resolve) {\n      var _this9 = this;\n\n      if (props.cancel) {\n        this.stop(true);\n        return resolve(getCancelledResult(this));\n      }\n\n      var hasToProp = !is.und(range.to);\n      var hasFromProp = !is.und(range.from);\n\n      if (hasToProp || hasFromProp) {\n        if (props.callId > this._lastToId) {\n          this._lastToId = props.callId;\n        } else {\n          return resolve(getCancelledResult(this));\n        }\n      }\n\n      var key = this.key,\n          defaultProps = this.defaultProps,\n          anim = this.animation;\n      var prevTo = anim.to,\n          prevFrom = anim.from;\n      var _range$to = range.to,\n          to = _range$to === void 0 ? prevTo : _range$to,\n          _range$from = range.from,\n          from = _range$from === void 0 ? prevFrom : _range$from;\n\n      if (hasFromProp && !hasToProp && (!props.default || is.und(to))) {\n        to = from;\n      }\n\n      if (props.reverse) {\n        var _ref7 = [from, to];\n        to = _ref7[0];\n        from = _ref7[1];\n      }\n\n      var hasFromChanged = !isEqual(from, prevFrom);\n\n      if (hasFromChanged) {\n        anim.from = from;\n      }\n\n      from = getFluidValue(from);\n      var hasToChanged = !isEqual(to, prevTo);\n\n      if (hasToChanged) {\n        this._focus(to);\n      }\n\n      var hasAsyncTo = isAsyncTo(props.to);\n      var config = anim.config;\n      var decay = config.decay,\n          velocity = config.velocity;\n\n      if (hasToProp || hasFromProp) {\n        config.velocity = 0;\n      }\n\n      if (props.config && !hasAsyncTo) {\n        mergeConfig(config, callProp(props.config, key), props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);\n      }\n\n      var node = getAnimated(this);\n\n      if (!node || is.und(to)) {\n        return resolve(getFinishedResult(this, true));\n      }\n\n      var reset = is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key);\n      var value = reset ? from : this.get();\n      var goal = computeGoal(to);\n      var isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);\n      var immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));\n\n      if (hasToChanged) {\n        var nodeType = getAnimatedType(to);\n\n        if (nodeType !== node.constructor) {\n          if (immediate) {\n            node = this._set(goal);\n          } else throw Error(\"Cannot animate between \".concat(node.constructor.name, \" and \").concat(nodeType.name, \", as the \\\"to\\\" prop suggests\"));\n        }\n      }\n\n      var goalType = node.constructor;\n      var started = hasFluidValue(to);\n      var finished = false;\n\n      if (!started) {\n        var hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;\n\n        if (hasToChanged || hasValueChanged) {\n          finished = isEqual(computeGoal(value), goal);\n          started = !finished;\n        }\n\n        if (!isEqual(config.decay, decay) || !isEqual(config.velocity, velocity)) {\n          started = true;\n        }\n      }\n\n      if (finished && isAnimating(this)) {\n        if (anim.changed && !reset) {\n          started = true;\n        } else if (!started) {\n          this._stop(prevTo);\n        }\n      }\n\n      if (!hasAsyncTo) {\n        if (started || hasFluidValue(prevTo)) {\n          anim.values = node.getPayload();\n          anim.toValues = hasFluidValue(to) ? null : goalType == AnimatedString ? [1] : toArray(goal);\n        }\n\n        if (anim.immediate != immediate) {\n          anim.immediate = immediate;\n\n          if (!immediate && !reset) {\n            this._set(prevTo);\n          }\n        }\n\n        if (started) {\n          var onRest = anim.onRest;\n          each(ACTIVE_EVENTS, function (type) {\n            return mergeActiveFn(_this9, props, type);\n          });\n          var result = getFinishedResult(this, checkFinished(this, prevTo));\n          flushCalls(this._pendingCalls, result);\n\n          this._pendingCalls.add(resolve);\n\n          if (anim.changed) raf.batchedUpdates(function () {\n            var _a;\n\n            anim.changed = !reset;\n            onRest == null ? void 0 : onRest(result);\n\n            if (reset) {\n              callProp(defaultProps.onRest, result);\n            } else {\n              (_a = anim.onStart) == null ? void 0 : _a.call(anim, _this9);\n            }\n          });\n        }\n      }\n\n      if (reset) {\n        this._set(value);\n      }\n\n      if (hasAsyncTo) {\n        resolve(runAsync(props.to, props, this._state, this));\n      } else if (started) {\n        this._start();\n      } else if (isAnimating(this) && !hasToChanged) {\n        this._pendingCalls.add(resolve);\n      } else {\n        resolve(getNoopResult(this, value));\n      }\n    }\n  }, {\n    key: \"_focus\",\n    value: function _focus(value) {\n      var anim = this.animation;\n\n      if (value !== anim.to) {\n        if (getFluidObservers(this)) {\n          this._detach();\n        }\n\n        anim.to = value;\n\n        if (getFluidObservers(this)) {\n          this._attach();\n        }\n      }\n    }\n  }, {\n    key: \"_attach\",\n    value: function _attach() {\n      var priority = 0;\n      var to = this.animation.to;\n\n      if (hasFluidValue(to)) {\n        addFluidObserver(to, this);\n\n        if (isFrameValue(to)) {\n          priority = to.priority + 1;\n        }\n      }\n\n      this.priority = priority;\n    }\n  }, {\n    key: \"_detach\",\n    value: function _detach() {\n      var to = this.animation.to;\n\n      if (hasFluidValue(to)) {\n        removeFluidObserver(to, this);\n      }\n    }\n  }, {\n    key: \"_set\",\n    value: function _set(arg) {\n      var _this10 = this;\n\n      var idle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var value = getFluidValue(arg);\n\n      if (!is.und(value)) {\n        var oldNode = getAnimated(this);\n\n        if (!oldNode || !isEqual(value, oldNode.getValue())) {\n          var nodeType = getAnimatedType(value);\n\n          if (!oldNode || oldNode.constructor != nodeType) {\n            setAnimated(this, nodeType.create(value));\n          } else {\n            oldNode.setValue(value);\n          }\n\n          if (oldNode) {\n            raf.batchedUpdates(function () {\n              _this10._onChange(value, idle);\n            });\n          }\n        }\n      }\n\n      return getAnimated(this);\n    }\n  }, {\n    key: \"_onStart\",\n    value: function _onStart() {\n      var anim = this.animation;\n\n      if (!anim.changed) {\n        anim.changed = true;\n        sendEvent(this, \"onStart\", this);\n      }\n    }\n  }, {\n    key: \"_onChange\",\n    value: function _onChange(value, idle) {\n      if (!idle) {\n        this._onStart();\n\n        callProp(this.animation.onChange, value, this);\n      }\n\n      callProp(this.defaultProps.onChange, value, this);\n\n      _get(_getPrototypeOf(SpringValue.prototype), \"_onChange\", this).call(this, value, idle);\n    }\n  }, {\n    key: \"_start\",\n    value: function _start() {\n      var anim = this.animation;\n      getAnimated(this).reset(getFluidValue(anim.to));\n\n      if (!anim.immediate) {\n        anim.fromValues = anim.values.map(function (node) {\n          return node.lastPosition;\n        });\n      }\n\n      if (!isAnimating(this)) {\n        setActiveBit(this, true);\n\n        if (!isPaused(this)) {\n          this._resume();\n        }\n      }\n    }\n  }, {\n    key: \"_resume\",\n    value: function _resume() {\n      if (Globals.skipAnimation) {\n        this.finish();\n      } else {\n        frameLoop.start(this);\n      }\n    }\n  }, {\n    key: \"_stop\",\n    value: function _stop(goal, cancel) {\n      if (isAnimating(this)) {\n        setActiveBit(this, false);\n        var anim = this.animation;\n        each(anim.values, function (node) {\n          node.done = true;\n        });\n\n        if (anim.toValues) {\n          anim.onChange = anim.onPause = anim.onResume = void 0;\n        }\n\n        callFluidObservers(this, {\n          type: \"idle\",\n          parent: this\n        });\n        var result = cancel ? getCancelledResult(this) : getFinishedResult(this, checkFinished(this, goal != null ? goal : anim.to));\n        flushCalls(this._pendingCalls, result);\n\n        if (anim.changed) {\n          anim.changed = false;\n          sendEvent(this, \"onRest\", result);\n        }\n      }\n    }\n  }]);\n\n  return SpringValue;\n}(FrameValue);\n\nfunction checkFinished(target, to) {\n  var goal = computeGoal(to);\n  var value = computeGoal(target.get());\n  return isEqual(value, goal);\n}\n\nfunction createLoopUpdate(props) {\n  var loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : props.loop;\n  var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : props.to;\n  var loopRet = callProp(loop);\n\n  if (loopRet) {\n    var overrides = loopRet !== true && inferTo(loopRet);\n    var reverse = (overrides || props).reverse;\n    var reset = !overrides || overrides.reset;\n    return createUpdate(_objectSpread(_objectSpread({}, props), {}, {\n      loop: loop,\n      default: false,\n      pause: void 0,\n      to: !reverse || isAsyncTo(to) ? to : void 0,\n      from: reset ? props.from : void 0,\n      reset: reset\n    }, overrides));\n  }\n}\n\nfunction createUpdate(props) {\n  var _props = props = inferTo(props),\n      to = _props.to,\n      from = _props.from;\n\n  var keys = new Set();\n  if (is.obj(to)) findDefined(to, keys);\n  if (is.obj(from)) findDefined(from, keys);\n  props.keys = keys.size ? Array.from(keys) : null;\n  return props;\n}\n\nfunction declareUpdate(props) {\n  var update = createUpdate(props);\n\n  if (is.und(update.default)) {\n    update.default = getDefaultProps(update);\n  }\n\n  return update;\n}\n\nfunction findDefined(values, keys) {\n  eachProp(values, function (value, key) {\n    return value != null && keys.add(key);\n  });\n}\n\nvar ACTIVE_EVENTS = [\"onStart\", \"onRest\", \"onChange\", \"onPause\", \"onResume\"];\n\nfunction mergeActiveFn(target, props, type) {\n  target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;\n}\n\nfunction sendEvent(target, type) {\n  var _b2, _d2;\n\n  var _a, _b, _c, _d;\n\n  for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n    args[_key4 - 2] = arguments[_key4];\n  }\n\n  (_b = (_a = target.animation)[type]) == null ? void 0 : (_b2 = _b).call.apply(_b2, [_a].concat(args));\n  (_d = (_c = target.defaultProps)[type]) == null ? void 0 : (_d2 = _d).call.apply(_d2, [_c].concat(args));\n}\n\nvar BATCHED_EVENTS = [\"onStart\", \"onChange\", \"onRest\"];\nvar nextId$1 = 1;\n\nvar Controller = /*#__PURE__*/function () {\n  function Controller(props, flush2) {\n    _classCallCheck(this, Controller);\n\n    this.id = nextId$1++;\n    this.springs = {};\n    this.queue = [];\n    this._lastAsyncId = 0;\n    this._active = new Set();\n    this._changed = new Set();\n    this._started = false;\n    this._state = {\n      paused: false,\n      pauseQueue: new Set(),\n      resumeQueue: new Set(),\n      timeouts: new Set()\n    };\n    this._events = {\n      onStart: new Set(),\n      onChange: new Set(),\n      onRest: new Map()\n    };\n    this._onFrame = this._onFrame.bind(this);\n\n    if (flush2) {\n      this._flush = flush2;\n    }\n\n    if (props) {\n      this.start(_objectSpread({\n        default: true\n      }, props));\n    }\n  }\n\n  _createClass(Controller, [{\n    key: \"idle\",\n    get: function get() {\n      return !this._state.asyncTo && Object.values(this.springs).every(function (spring) {\n        return spring.idle;\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      var values = {};\n      this.each(function (spring, key) {\n        return values[key] = spring.get();\n      });\n      return values;\n    }\n  }, {\n    key: \"set\",\n    value: function set(values) {\n      for (var key in values) {\n        var value = values[key];\n\n        if (!is.und(value)) {\n          this.springs[key].set(value);\n        }\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(props) {\n      if (props) {\n        this.queue.push(createUpdate(props));\n      }\n\n      return this;\n    }\n  }, {\n    key: \"start\",\n    value: function start(props) {\n      var queue = this.queue;\n\n      if (props) {\n        queue = toArray(props).map(createUpdate);\n      } else {\n        this.queue = [];\n      }\n\n      if (this._flush) {\n        return this._flush(this, queue);\n      }\n\n      prepareKeys(this, queue);\n      return flushUpdateQueue(this, queue);\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(arg, keys) {\n      if (arg !== !!arg) {\n        keys = arg;\n      }\n\n      if (keys) {\n        var springs = this.springs;\n        each(toArray(keys), function (key) {\n          return springs[key].stop(!!arg);\n        });\n      } else {\n        stopAsync(this._state, this._lastAsyncId);\n        this.each(function (spring) {\n          return spring.stop(!!arg);\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"pause\",\n    value: function pause(keys) {\n      if (is.und(keys)) {\n        this.start({\n          pause: true\n        });\n      } else {\n        var springs = this.springs;\n        each(toArray(keys), function (key) {\n          return springs[key].pause();\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"resume\",\n    value: function resume(keys) {\n      if (is.und(keys)) {\n        this.start({\n          pause: false\n        });\n      } else {\n        var springs = this.springs;\n        each(toArray(keys), function (key) {\n          return springs[key].resume();\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"each\",\n    value: function each(iterator) {\n      eachProp(this.springs, iterator);\n    }\n  }, {\n    key: \"_onFrame\",\n    value: function _onFrame() {\n      var _this$_events = this._events,\n          onStart = _this$_events.onStart,\n          onChange = _this$_events.onChange,\n          onRest = _this$_events.onRest;\n      var active = this._active.size > 0;\n\n      if (active && !this._started) {\n        this._started = true;\n        flushCalls(onStart, this);\n      }\n\n      var idle = !active && this._started;\n      var changed = this._changed.size > 0 && onChange.size;\n      var values = changed || idle && onRest.size ? this.get() : null;\n\n      if (changed) {\n        flushCalls(onChange, values);\n      }\n\n      if (idle) {\n        this._started = false;\n        flush(onRest, function (_ref8) {\n          var _ref9 = _slicedToArray(_ref8, 2),\n              onRest2 = _ref9[0],\n              result = _ref9[1];\n\n          result.value = values;\n          onRest2(result);\n        });\n      }\n    }\n  }, {\n    key: \"eventObserved\",\n    value: function eventObserved(event) {\n      if (event.type == \"change\") {\n        this._changed.add(event.parent);\n\n        if (!event.idle) {\n          this._active.add(event.parent);\n        }\n      } else if (event.type == \"idle\") {\n        this._active.delete(event.parent);\n      } else return;\n\n      raf.onFrame(this._onFrame);\n    }\n  }]);\n\n  return Controller;\n}();\n\nfunction flushUpdateQueue(ctrl, queue) {\n  return Promise.all(queue.map(function (props) {\n    return flushUpdate(ctrl, props);\n  })).then(function (results) {\n    return getCombinedResult(ctrl, results);\n  });\n}\n\nfunction flushUpdate(_x2, _x3, _x4) {\n  return _flushUpdate.apply(this, arguments);\n}\n\nfunction _flushUpdate() {\n  _flushUpdate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(ctrl, props, isLoop) {\n    var keys, to, from, loop, onRest, onResolve, defaults, asyncTo, state, promises, cancel, result, nextProps;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            keys = props.keys, to = props.to, from = props.from, loop = props.loop, onRest = props.onRest, onResolve = props.onResolve;\n            defaults = is.obj(props.default) && props.default;\n\n            if (loop) {\n              props.loop = false;\n            }\n\n            if (to === false) props.to = null;\n            if (from === false) props.from = null;\n            asyncTo = is.arr(to) || is.fun(to) ? to : void 0;\n\n            if (asyncTo) {\n              props.to = void 0;\n              props.onRest = void 0;\n\n              if (defaults) {\n                defaults.onRest = void 0;\n              }\n            } else {\n              each(BATCHED_EVENTS, function (key) {\n                var handler = props[key];\n\n                if (is.fun(handler)) {\n                  var queue = ctrl[\"_events\"][key];\n\n                  if (queue instanceof Set) {\n                    props[key] = function () {\n                      return queue.add(handler);\n                    };\n                  } else {\n                    props[key] = function (_ref18) {\n                      var finished = _ref18.finished,\n                          cancelled = _ref18.cancelled;\n                      var result2 = queue.get(handler);\n\n                      if (result2) {\n                        if (!finished) result2.finished = false;\n                        if (cancelled) result2.cancelled = true;\n                      } else {\n                        queue.set(handler, {\n                          target: ctrl,\n                          value: null,\n                          finished: finished,\n                          cancelled: cancelled\n                        });\n                      }\n                    };\n                  }\n\n                  if (defaults) {\n                    defaults[key] = props[key];\n                  }\n                }\n              });\n            }\n\n            state = ctrl[\"_state\"];\n\n            if (props.pause === !state.paused) {\n              state.paused = props.pause;\n              flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);\n            } else if (state.paused) {\n              props.pause = true;\n            }\n\n            promises = (keys || Object.keys(ctrl.springs)).map(function (key) {\n              return ctrl.springs[key].start(props);\n            });\n            cancel = props.cancel === true || getDefaultProp(props, \"cancel\") === true;\n\n            if (asyncTo || cancel && state.asyncId) {\n              promises.push(scheduleProps(++ctrl[\"_lastAsyncId\"], {\n                props: props,\n                state: state,\n                actions: {\n                  pause: noop,\n                  resume: noop,\n                  start: function start(props2, resolve) {\n                    if (cancel) {\n                      stopAsync(state, ctrl[\"_lastAsyncId\"]);\n                      resolve(getCancelledResult(ctrl));\n                    } else {\n                      props2.onRest = onRest;\n                      resolve(runAsync(asyncTo, props2, state, ctrl));\n                    }\n                  }\n                }\n              }));\n            }\n\n            if (!state.paused) {\n              _context4.next = 15;\n              break;\n            }\n\n            _context4.next = 15;\n            return new Promise(function (resume) {\n              state.resumeQueue.add(resume);\n            });\n\n          case 15:\n            _context4.t0 = getCombinedResult;\n            _context4.t1 = ctrl;\n            _context4.next = 19;\n            return Promise.all(promises);\n\n          case 19:\n            _context4.t2 = _context4.sent;\n            result = (0, _context4.t0)(_context4.t1, _context4.t2);\n\n            if (!(loop && result.finished && !(isLoop && result.noop))) {\n              _context4.next = 26;\n              break;\n            }\n\n            nextProps = createLoopUpdate(props, loop, to);\n\n            if (!nextProps) {\n              _context4.next = 26;\n              break;\n            }\n\n            prepareKeys(ctrl, [nextProps]);\n            return _context4.abrupt(\"return\", flushUpdate(ctrl, nextProps, true));\n\n          case 26:\n            if (onResolve) {\n              raf.batchedUpdates(function () {\n                return onResolve(result);\n              });\n            }\n\n            return _context4.abrupt(\"return\", result);\n\n          case 28:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _flushUpdate.apply(this, arguments);\n}\n\nfunction getSprings(ctrl, props) {\n  var springs = _objectSpread({}, ctrl.springs);\n\n  if (props) {\n    each(toArray(props), function (props2) {\n      if (is.und(props2.keys)) {\n        props2 = createUpdate(props2);\n      }\n\n      if (!is.obj(props2.to)) {\n        props2 = _objectSpread(_objectSpread({}, props2), {}, {\n          to: void 0\n        });\n      }\n\n      prepareSprings(springs, props2, function (key) {\n        return createSpring(key);\n      });\n    });\n  }\n\n  return springs;\n}\n\nfunction setSprings(ctrl, springs) {\n  eachProp(springs, function (spring, key) {\n    if (!ctrl.springs[key]) {\n      ctrl.springs[key] = spring;\n      addFluidObserver(spring, ctrl);\n    }\n  });\n}\n\nfunction createSpring(key, observer) {\n  var spring = new SpringValue();\n  spring.key = key;\n\n  if (observer) {\n    addFluidObserver(spring, observer);\n  }\n\n  return spring;\n}\n\nfunction prepareSprings(springs, props, create) {\n  if (props.keys) {\n    each(props.keys, function (key) {\n      var spring = springs[key] || (springs[key] = create(key));\n      spring[\"_prepareNode\"](props);\n    });\n  }\n}\n\nfunction prepareKeys(ctrl, queue) {\n  each(queue, function (props) {\n    prepareSprings(ctrl.springs, props, function (key) {\n      return createSpring(key, ctrl);\n    });\n  });\n}\n\nvar SpringContext = function SpringContext(_ref10) {\n  var children = _ref10.children,\n      props = _objectWithoutProperties(_ref10, _excluded);\n\n  var inherited = useContext(ctx);\n  var pause = props.pause || !!inherited.pause,\n      immediate = props.immediate || !!inherited.immediate;\n  props = useMemoOne(function () {\n    return {\n      pause: pause,\n      immediate: immediate\n    };\n  }, [pause, immediate]);\n  var Provider = ctx.Provider;\n  return /* @__PURE__ */createElement(Provider, {\n    value: props\n  }, children);\n};\n\nvar ctx = makeContext(SpringContext, {});\nSpringContext.Provider = ctx.Provider;\nSpringContext.Consumer = ctx.Consumer;\n\nfunction makeContext(target, init) {\n  Object.assign(target, createContext(init));\n  target.Provider._context = target;\n  target.Consumer._context = target;\n  return target;\n}\n\nvar SpringRef = /*#__PURE__*/function () {\n  function SpringRef() {\n    _classCallCheck(this, SpringRef);\n\n    this.current = [];\n  }\n\n  _createClass(SpringRef, [{\n    key: \"set\",\n    value: function set(values) {\n      each(this.current, function (ctrl) {\n        return ctrl.set(values);\n      });\n    }\n  }, {\n    key: \"start\",\n    value: function start(props) {\n      var _this11 = this;\n\n      var results = [];\n      each(this.current, function (ctrl, i) {\n        if (is.und(props)) {\n          results.push(ctrl.start());\n        } else {\n          var _update2 = _this11._getProps(props, ctrl, i);\n\n          if (_update2) {\n            results.push(ctrl.start(_update2));\n          }\n        }\n      });\n      return results;\n    }\n  }, {\n    key: \"update\",\n    value: function update(props) {\n      var _this12 = this;\n\n      each(this.current, function (ctrl, i) {\n        return ctrl.update(_this12._getProps(props, ctrl, i));\n      });\n      return this;\n    }\n  }, {\n    key: \"add\",\n    value: function add(ctrl) {\n      if (!this.current.includes(ctrl)) {\n        this.current.push(ctrl);\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(ctrl) {\n      var i = this.current.indexOf(ctrl);\n      if (~i) this.current.splice(i, 1);\n    }\n  }, {\n    key: \"_getProps\",\n    value: function _getProps(arg, ctrl, index) {\n      return is.fun(arg) ? arg(index, ctrl) : arg;\n    }\n  }]);\n\n  return SpringRef;\n}();\n\neach([\"stop\", \"pause\", \"resume\"], function (key) {\n  SpringRef.prototype[key] = function () {\n    var _arguments = arguments;\n    each(this.current, function (ctrl) {\n      return ctrl[key].apply(ctrl, _toConsumableArray(_arguments));\n    });\n    return this;\n  };\n});\n\nfunction useSprings(length, props, deps) {\n  var _arguments2 = arguments;\n  var propsFn = is.fun(props) && props;\n  if (propsFn && !deps) deps = [];\n  var ref = useMemo(function () {\n    return propsFn || _arguments2.length == 3 ? new SpringRef() : void 0;\n  }, []);\n  var layoutId = useRef(0);\n  var forceUpdate = useForceUpdate();\n  var state = useMemo(function () {\n    return {\n      ctrls: [],\n      queue: [],\n      flush: function flush(ctrl, updates2) {\n        var springs2 = getSprings(ctrl, updates2);\n        var canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some(function (key) {\n          return !ctrl.springs[key];\n        });\n        return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise(function (resolve) {\n          setSprings(ctrl, springs2);\n          state.queue.push(function () {\n            resolve(flushUpdateQueue(ctrl, updates2));\n          });\n          forceUpdate();\n        });\n      }\n    };\n  }, []);\n\n  var ctrls = _toConsumableArray(state.ctrls);\n\n  var updates = [];\n  var prevLength = usePrev(length) || 0;\n  var oldCtrls = ctrls.slice(length, prevLength);\n  useMemo(function () {\n    ctrls.length = length;\n    declareUpdates(prevLength, length);\n  }, [length]);\n  useMemo(function () {\n    declareUpdates(0, Math.min(prevLength, length));\n  }, deps);\n\n  function declareUpdates(startIndex, endIndex) {\n    for (var i = startIndex; i < endIndex; i++) {\n      var ctrl = ctrls[i] || (ctrls[i] = new Controller(null, state.flush));\n\n      var _update3 = propsFn ? propsFn(i, ctrl) : props[i];\n\n      if (_update3) {\n        updates[i] = declareUpdate(_update3);\n      }\n    }\n  }\n\n  var springs = ctrls.map(function (ctrl, i) {\n    return getSprings(ctrl, updates[i]);\n  });\n  var context = useContext(SpringContext);\n  var prevContext = usePrev(context);\n  var hasContext = context !== prevContext && hasProps(context);\n  useLayoutEffect(function () {\n    layoutId.current++;\n    state.ctrls = ctrls;\n    var queue = state.queue;\n\n    if (queue.length) {\n      state.queue = [];\n      each(queue, function (cb) {\n        return cb();\n      });\n    }\n\n    each(oldCtrls, function (ctrl) {\n      detachRefs(ctrl, ref);\n      ctrl.stop(true);\n    });\n    each(ctrls, function (ctrl, i) {\n      var values2 = springs[i];\n      setSprings(ctrl, values2);\n      ref == null ? void 0 : ref.add(ctrl);\n\n      if (hasContext) {\n        ctrl.start({\n          default: context\n        });\n      }\n\n      var update = updates[i];\n\n      if (update) {\n        replaceRef(ctrl, update.ref);\n\n        if (ctrl.ref) {\n          ctrl.queue.push(update);\n        } else {\n          ctrl.start(update);\n        }\n      }\n    });\n  });\n  useOnce(function () {\n    return function () {\n      each(state.ctrls, function (ctrl) {\n        return ctrl.stop(true);\n      });\n    };\n  });\n  var values = springs.map(function (x) {\n    return _objectSpread({}, x);\n  });\n  return ref ? [values, ref] : values;\n}\n\nfunction useSpring(props, deps) {\n  var isFn = is.fun(props);\n\n  var _useSprings = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps),\n      _useSprings2 = _slicedToArray(_useSprings, 2),\n      _useSprings2$ = _slicedToArray(_useSprings2[0], 1),\n      values = _useSprings2$[0],\n      ref = _useSprings2[1];\n\n  return isFn || arguments.length == 2 ? [values, ref] : values;\n}\n\nvar initSpringRef = function initSpringRef() {\n  return new SpringRef();\n};\n\nvar useSpringRef = function useSpringRef() {\n  return useState(initSpringRef)[0];\n};\n\nfunction useTrail(length, propsArg, deps) {\n  var propsFn = is.fun(propsArg) && propsArg;\n  if (propsFn && !deps) deps = [];\n  var reverse = true;\n  var result = useSprings(length, function (i, ctrl) {\n    var props = propsFn ? propsFn(i, ctrl) : propsArg;\n    reverse = reverse && props.reverse;\n    return props;\n  }, deps || [{}]);\n  var ref = result[1];\n  useLayoutEffect(function () {\n    each(ref.current, function (ctrl, i) {\n      var parent = ref.current[i + (reverse ? 1 : -1)];\n      if (parent) ctrl.start({\n        to: parent.springs\n      });\n    });\n  }, deps);\n\n  if (propsFn || arguments.length == 3) {\n    ref[\"_getProps\"] = function (propsArg2, ctrl, i) {\n      var props = is.fun(propsArg2) ? propsArg2(i, ctrl) : propsArg2;\n\n      if (props) {\n        var parent = ref.current[i + (props.reverse ? 1 : -1)];\n        if (parent) props.to = parent.springs;\n        return props;\n      }\n    };\n\n    return result;\n  }\n\n  return result[0];\n}\n\nvar MOUNT = \"mount\";\nvar ENTER = \"enter\";\nvar UPDATE = \"update\";\nvar LEAVE = \"leave\";\n\nfunction useTransition(data, props, deps) {\n  var _arguments3 = arguments;\n  var reset = props.reset,\n      sort = props.sort,\n      _props$trail = props.trail,\n      trail = _props$trail === void 0 ? 0 : _props$trail,\n      _props$expires = props.expires,\n      expires = _props$expires === void 0 ? true : _props$expires,\n      onDestroyed = props.onDestroyed;\n  var ref = useMemo(function () {\n    return _arguments3.length == 3 ? new SpringRef() : void 0;\n  }, []);\n  var items = toArray(data);\n  var transitions = [];\n  var usedTransitions = useRef(null);\n  var prevTransitions = reset ? null : usedTransitions.current;\n  useLayoutEffect(function () {\n    usedTransitions.current = transitions;\n  });\n  useOnce(function () {\n    return function () {\n      return each(usedTransitions.current, function (t) {\n        if (t.expired) {\n          clearTimeout(t.expirationId);\n        }\n\n        detachRefs(t.ctrl, ref);\n        t.ctrl.stop(true);\n      });\n    };\n  });\n  var keys = getKeys(items, props, prevTransitions);\n  var expired = reset && usedTransitions.current || [];\n  useLayoutEffect(function () {\n    return each(expired, function (_ref11) {\n      var ctrl = _ref11.ctrl,\n          item = _ref11.item,\n          key = _ref11.key;\n      detachRefs(ctrl, ref);\n      callProp(onDestroyed, item, key);\n    });\n  });\n  var reused = [];\n  if (prevTransitions) each(prevTransitions, function (t, i) {\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n      expired.push(t);\n    } else {\n      i = reused[i] = keys.indexOf(t.key);\n      if (~i) transitions[i] = t;\n    }\n  });\n  each(items, function (item, i) {\n    transitions[i] || (transitions[i] = {\n      key: keys[i],\n      item: item,\n      phase: MOUNT,\n      ctrl: new Controller()\n    });\n  });\n\n  if (reused.length) {\n    var i = -1;\n    each(reused, function (keyIndex, prevIndex) {\n      var t = prevTransitions[prevIndex];\n\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = _objectSpread(_objectSpread({}, t), {}, {\n          item: items[keyIndex]\n        });\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n\n  if (is.fun(sort)) {\n    transitions.sort(function (a, b) {\n      return sort(a.item, b.item);\n    });\n  }\n\n  var delay = -trail;\n  var forceUpdate = useForceUpdate();\n  var defaultProps = getDefaultProps(props);\n  var changes = new Map();\n  each(transitions, function (t, i) {\n    var key = t.key;\n    var prevPhase = t.phase;\n    var to;\n    var phase;\n\n    if (prevPhase == MOUNT) {\n      to = props.enter;\n      phase = ENTER;\n    } else {\n      var isLeave = keys.indexOf(key) < 0;\n\n      if (prevPhase != LEAVE) {\n        if (isLeave) {\n          to = props.leave;\n          phase = LEAVE;\n        } else if (to = props.update) {\n          phase = UPDATE;\n        } else return;\n      } else if (!isLeave) {\n        to = props.enter;\n        phase = ENTER;\n      } else return;\n    }\n\n    to = callProp(to, t.item, i);\n    to = is.obj(to) ? inferTo(to) : {\n      to: to\n    };\n\n    if (!to.config) {\n      var _config2 = props.config || defaultProps.config;\n\n      to.config = callProp(_config2, t.item, i);\n    }\n\n    var payload = _objectSpread(_objectSpread({}, defaultProps), {}, {\n      delay: delay += trail,\n      reset: false\n    }, to);\n\n    if (phase == ENTER && is.und(payload.from)) {\n      var from = is.und(props.initial) || prevTransitions ? props.from : props.initial;\n      payload.from = callProp(from, t.item, i);\n    }\n\n    var onResolve = payload.onResolve;\n\n    payload.onResolve = function (result) {\n      callProp(onResolve, result);\n      var transitions2 = usedTransitions.current;\n      var t2 = transitions2.find(function (t3) {\n        return t3.key === key;\n      });\n      if (!t2) return;\n\n      if (result.cancelled && t2.phase != UPDATE) {\n        t2.phase = prevPhase;\n        return;\n      }\n\n      if (t2.ctrl.idle) {\n        var idle = transitions2.every(function (t3) {\n          return t3.ctrl.idle;\n        });\n\n        if (t2.phase == LEAVE) {\n          var expiry = callProp(expires, t2.item);\n\n          if (expiry !== false) {\n            var expiryMs = expiry === true ? 0 : expiry;\n            t2.expired = true;\n\n            if (!idle && expiryMs > 0) {\n              if (expiryMs <= 2147483647) t2.expirationId = setTimeout(forceUpdate, expiryMs);\n              return;\n            }\n          }\n        }\n\n        if (idle && transitions2.some(function (t3) {\n          return t3.expired;\n        })) {\n          forceUpdate();\n        }\n      }\n    };\n\n    var springs = getSprings(t.ctrl, payload);\n    changes.set(t, {\n      phase: phase,\n      springs: springs,\n      payload: payload\n    });\n  });\n  var context = useContext(SpringContext);\n  var prevContext = usePrev(context);\n  var hasContext = context !== prevContext && hasProps(context);\n  useLayoutEffect(function () {\n    if (hasContext) each(transitions, function (t) {\n      t.ctrl.start({\n        default: context\n      });\n    });\n  }, [context]);\n  useLayoutEffect(function () {\n    each(changes, function (_ref12, t) {\n      var phase = _ref12.phase,\n          springs = _ref12.springs,\n          payload = _ref12.payload;\n      var ctrl = t.ctrl;\n      t.phase = phase;\n      ref == null ? void 0 : ref.add(ctrl);\n      replaceRef(ctrl, payload.ref);\n      setSprings(ctrl, springs);\n\n      if (hasContext && phase == ENTER) {\n        ctrl.start({\n          default: context\n        });\n      }\n\n      ctrl[ctrl.ref ? \"update\" : \"start\"](payload);\n    });\n  }, reset ? void 0 : deps);\n\n  var renderTransitions = function renderTransitions(render) {\n    return /* @__PURE__ */createElement(Fragment, null, transitions.map(function (t, i) {\n      var _ref13 = changes.get(t) || t.ctrl,\n          springs = _ref13.springs;\n\n      var elem = render(_objectSpread({}, springs), t.item, t, i);\n      return elem && elem.type ? /* @__PURE__ */createElement(elem.type, _objectSpread(_objectSpread({}, elem.props), {}, {\n        key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,\n        ref: elem.ref\n      })) : elem;\n    }));\n  };\n\n  return ref ? [renderTransitions, ref] : renderTransitions;\n}\n\nvar nextKey = 1;\n\nfunction getKeys(items, _ref14, prevTransitions) {\n  var key = _ref14.key,\n      _ref14$keys = _ref14.keys,\n      keys = _ref14$keys === void 0 ? key : _ref14$keys;\n\n  if (keys === null) {\n    var reused = new Set();\n    return items.map(function (item) {\n      var t = prevTransitions && prevTransitions.find(function (t2) {\n        return t2.item === item && t2.phase !== LEAVE && !reused.has(t2);\n      });\n\n      if (t) {\n        reused.add(t);\n        return t.key;\n      }\n\n      return nextKey++;\n    });\n  }\n\n  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);\n}\n\nfunction Spring(_ref15) {\n  var children = _ref15.children,\n      props = _objectWithoutProperties(_ref15, _excluded2);\n\n  return children(useSpring(props));\n}\n\nfunction Trail(_ref16) {\n  var items = _ref16.items,\n      children = _ref16.children,\n      props = _objectWithoutProperties(_ref16, _excluded3);\n\n  var trails = useTrail(items.length, props);\n  return items.map(function (item, index) {\n    var result = children(item, index);\n    return is.fun(result) ? result(trails[index]) : result;\n  });\n}\n\nfunction Transition(_ref17) {\n  var items = _ref17.items,\n      children = _ref17.children,\n      props = _objectWithoutProperties(_ref17, _excluded4);\n\n  return useTransition(items, props)(children);\n}\n\nvar Interpolation = /*#__PURE__*/function (_FrameValue2) {\n  _inherits(Interpolation, _FrameValue2);\n\n  var _super4 = _createSuper(Interpolation);\n\n  function Interpolation(source, args) {\n    var _this13;\n\n    _classCallCheck(this, Interpolation);\n\n    _this13 = _super4.call(this);\n    _this13.source = source;\n    _this13.idle = true;\n    _this13._active = new Set();\n    _this13.calc = createInterpolator.apply(void 0, _toConsumableArray(args));\n\n    var value = _this13._get();\n\n    var nodeType = getAnimatedType(value);\n    setAnimated(_assertThisInitialized(_this13), nodeType.create(value));\n    return _this13;\n  }\n\n  _createClass(Interpolation, [{\n    key: \"advance\",\n    value: function advance(_dt) {\n      var value = this._get();\n\n      var oldValue = this.get();\n\n      if (!isEqual(value, oldValue)) {\n        getAnimated(this).setValue(value);\n\n        this._onChange(value, this.idle);\n      }\n\n      if (!this.idle && checkIdle(this._active)) {\n        becomeIdle(this);\n      }\n    }\n  }, {\n    key: \"_get\",\n    value: function _get() {\n      var inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));\n      return this.calc.apply(this, _toConsumableArray(inputs));\n    }\n  }, {\n    key: \"_start\",\n    value: function _start() {\n      var _this14 = this;\n\n      if (this.idle && !checkIdle(this._active)) {\n        this.idle = false;\n        each(getPayload(this), function (node) {\n          node.done = false;\n        });\n\n        if (Globals.skipAnimation) {\n          raf.batchedUpdates(function () {\n            return _this14.advance();\n          });\n          becomeIdle(this);\n        } else {\n          frameLoop.start(this);\n        }\n      }\n    }\n  }, {\n    key: \"_attach\",\n    value: function _attach() {\n      var _this15 = this;\n\n      var priority = 1;\n      each(toArray(this.source), function (source) {\n        if (hasFluidValue(source)) {\n          addFluidObserver(source, _this15);\n        }\n\n        if (isFrameValue(source)) {\n          if (!source.idle) {\n            _this15._active.add(source);\n          }\n\n          priority = Math.max(priority, source.priority + 1);\n        }\n      });\n      this.priority = priority;\n\n      this._start();\n    }\n  }, {\n    key: \"_detach\",\n    value: function _detach() {\n      var _this16 = this;\n\n      each(toArray(this.source), function (source) {\n        if (hasFluidValue(source)) {\n          removeFluidObserver(source, _this16);\n        }\n      });\n\n      this._active.clear();\n\n      becomeIdle(this);\n    }\n  }, {\n    key: \"eventObserved\",\n    value: function eventObserved(event) {\n      if (event.type == \"change\") {\n        if (event.idle) {\n          this.advance();\n        } else {\n          this._active.add(event.parent);\n\n          this._start();\n        }\n      } else if (event.type == \"idle\") {\n        this._active.delete(event.parent);\n      } else if (event.type == \"priority\") {\n        this.priority = toArray(this.source).reduce(function (highest, parent) {\n          return Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1);\n        }, 0);\n      }\n    }\n  }]);\n\n  return Interpolation;\n}(FrameValue);\n\nfunction isIdle(source) {\n  return source.idle !== false;\n}\n\nfunction checkIdle(active) {\n  return !active.size || Array.from(active).every(isIdle);\n}\n\nfunction becomeIdle(self) {\n  if (!self.idle) {\n    self.idle = true;\n    each(getPayload(self), function (node) {\n      node.done = true;\n    });\n    callFluidObservers(self, {\n      type: \"idle\",\n      parent: self\n    });\n  }\n}\n\nvar to = function to(source) {\n  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    args[_key5 - 1] = arguments[_key5];\n  }\n\n  return new Interpolation(source, args);\n};\n\nvar interpolate = function interpolate(source) {\n  for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    args[_key6 - 1] = arguments[_key6];\n  }\n\n  return deprecateInterpolate(), new Interpolation(source, args);\n};\n\nGlobals.assign({\n  createStringInterpolator: createStringInterpolator,\n  to: function to(source, args) {\n    return new Interpolation(source, args);\n  }\n});\nvar update = frameLoop.advance;\nexport { BailSignal, Controller, FrameValue, Interpolation, Spring, SpringContext, SpringRef, SpringValue, Trail, Transition, config, inferTo, interpolate, to, update, useChain, useSpring, useSpringRef, useSprings, useTrail, useTransition };","map":{"version":3,"sources":["src/helpers.ts","src/hooks/useChain.ts","src/constants.ts","src/AnimationConfig.ts","src/Animation.ts","src/scheduleProps.ts","src/AnimationResult.ts","src/runAsync.ts","src/FrameValue.ts","src/SpringPhase.ts","src/SpringValue.ts","src/Controller.ts","src/SpringContext.tsx","src/SpringRef.ts","src/hooks/useSprings.ts","src/hooks/useSpring.ts","src/hooks/useSpringRef.ts","src/hooks/useTrail.ts","src/TransitionPhase.ts","src/hooks/useTransition.tsx","src/components/Spring.tsx","src/components/Trail.tsx","src/components/Transition.tsx","src/Interpolation.ts","src/interpolate.ts","src/globals.ts"],"names":["G","configs","AnimationConfig2","Animation2","scheduleProps2","runAsync2","nextId","SpringValue2","React.createContext","SpringRef2","Controller2","SpringContext2","useSprings2","useSpring2","useTrail2","Interpolation2"],"mappings":"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","sourcesContent":["import { useLayoutEffect } from 'react-layout-effect';\nimport { eachProp, is, toArray, isAnimatedString, Globals, getFluidValue, each, raf, flush, FluidValue, deprecateInterpolate, callFluidObservers, frameLoop, hasFluidValue, flushCalls, isEqual, getFluidObservers, addFluidObserver, removeFluidObserver, noop, useMemoOne, useForceUpdate, usePrev, useOnce, createInterpolator, createStringInterpolator } from '@react-spring/shared';\nexport { Globals, createInterpolator } from '@react-spring/shared';\nimport { useContext, createElement, createContext, useMemo, useRef, useState, Fragment } from 'react';\nimport { getAnimated, AnimatedValue, getPayload, AnimatedString, getAnimatedType, setAnimated } from '@react-spring/animated';\nexport * from '@react-spring/types/animated';\nexport * from '@react-spring/types/interpolation';\n\nfunction callProp(value, ...args) {\n  return is.fun(value) ? value(...args) : value;\n}\nconst matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));\nconst resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;\nconst getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;\nconst noopTransform = (value) => value;\nconst getDefaultProps = (props, transform = noopTransform) => {\n  let keys = DEFAULT_PROPS;\n  if (props.default && props.default !== true) {\n    props = props.default;\n    keys = Object.keys(props);\n  }\n  const defaults = {};\n  for (const key of keys) {\n    const value = transform(props[key], key);\n    if (!is.und(value)) {\n      defaults[key] = value;\n    }\n  }\n  return defaults;\n};\nconst DEFAULT_PROPS = [\n  \"config\",\n  \"onProps\",\n  \"onStart\",\n  \"onChange\",\n  \"onPause\",\n  \"onResume\",\n  \"onRest\"\n];\nconst RESERVED_PROPS = {\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  loop: 1,\n  reset: 1,\n  pause: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  onProps: 1,\n  onStart: 1,\n  onChange: 1,\n  onPause: 1,\n  onResume: 1,\n  onRest: 1,\n  onResolve: 1,\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  update: 1,\n  leave: 1,\n  children: 1,\n  onDestroyed: 1,\n  keys: 1,\n  callId: 1,\n  parentId: 1\n};\nfunction getForwardProps(props) {\n  const forward = {};\n  let count = 0;\n  eachProp(props, (value, prop) => {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n      count++;\n    }\n  });\n  if (count) {\n    return forward;\n  }\n}\nfunction inferTo(props) {\n  const to = getForwardProps(props);\n  if (to) {\n    const out = {to};\n    eachProp(props, (val, key) => key in to || (out[key] = val));\n    return out;\n  }\n  return {...props};\n}\nfunction computeGoal(value) {\n  value = getFluidValue(value);\n  return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? Globals.createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\nfunction hasProps(props) {\n  for (const _ in props)\n    return true;\n  return false;\n}\nfunction isAsyncTo(to) {\n  return is.fun(to) || is.arr(to) && is.obj(to[0]);\n}\nfunction detachRefs(ctrl, ref) {\n  var _a;\n  (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);\n  ref == null ? void 0 : ref.delete(ctrl);\n}\nfunction replaceRef(ctrl, ref) {\n  var _a;\n  if (ref && ctrl.ref !== ref) {\n    (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);\n    ref.add(ctrl);\n    ctrl.ref = ref;\n  }\n}\n\nfunction useChain(refs, timeSteps, timeFrame = 1e3) {\n  useLayoutEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0;\n      each(refs, (ref, i) => {\n        const controllers = ref.current;\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i];\n          if (isNaN(delay))\n            delay = prevDelay;\n          else\n            prevDelay = delay;\n          each(controllers, (ctrl) => {\n            each(ctrl.queue, (props) => {\n              props.delay = (key) => delay + callProp(props.delay || 0, key);\n            });\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      let p = Promise.resolve();\n      each(refs, (ref) => {\n        const controllers = ref.current;\n        if (controllers.length) {\n          const queues = controllers.map((ctrl) => {\n            const q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          });\n          p = p.then(() => {\n            each(controllers, (ctrl, i) => each(queues[i] || [], (update) => ctrl.queue.push(update)));\n            return ref.start();\n          });\n        }\n      });\n    }\n  });\n}\n\nconst config = {\n  default: {tension: 170, friction: 26},\n  gentle: {tension: 120, friction: 14},\n  wobbly: {tension: 180, friction: 12},\n  stiff: {tension: 210, friction: 20},\n  slow: {tension: 280, friction: 60},\n  molasses: {tension: 280, friction: 120}\n};\n\nconst linear = (t) => t;\nconst defaults = {\n  ...config.default,\n  mass: 1,\n  damping: 1,\n  easing: linear,\n  clamp: false\n};\nclass AnimationConfig {\n  constructor() {\n    this.velocity = 0;\n    Object.assign(this, defaults);\n  }\n}\nfunction mergeConfig(config, newConfig, defaultConfig) {\n  if (defaultConfig) {\n    defaultConfig = {...defaultConfig};\n    sanitizeConfig(defaultConfig, newConfig);\n    newConfig = {...defaultConfig, ...newConfig};\n  }\n  sanitizeConfig(config, newConfig);\n  Object.assign(config, newConfig);\n  for (const key in defaults) {\n    if (config[key] == null) {\n      config[key] = defaults[key];\n    }\n  }\n  let {mass, frequency, damping} = config;\n  if (!is.und(frequency)) {\n    if (frequency < 0.01)\n      frequency = 0.01;\n    if (damping < 0)\n      damping = 0;\n    config.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;\n    config.friction = 4 * Math.PI * damping * mass / frequency;\n  }\n  return config;\n}\nfunction sanitizeConfig(config, props) {\n  if (!is.und(props.decay)) {\n    config.duration = void 0;\n  } else {\n    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);\n    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {\n      config.duration = void 0;\n      config.decay = void 0;\n    }\n    if (isTensionConfig) {\n      config.frequency = void 0;\n    }\n  }\n}\n\nconst emptyArray = [];\nclass Animation {\n  constructor() {\n    this.changed = false;\n    this.values = emptyArray;\n    this.toValues = null;\n    this.fromValues = emptyArray;\n    this.config = new AnimationConfig();\n    this.immediate = false;\n  }\n}\n\nfunction scheduleProps(callId, {key, props, defaultProps, state, actions}) {\n  return new Promise((resolve, reject) => {\n    var _a;\n    let delay;\n    let timeout;\n    let cancel = matchProp((_a = props.cancel) != null ? _a : defaultProps == null ? void 0 : defaultProps.cancel, key);\n    if (cancel) {\n      onStart();\n    } else {\n      if (!is.und(props.pause)) {\n        state.paused = matchProp(props.pause, key);\n      }\n      let pause = defaultProps == null ? void 0 : defaultProps.pause;\n      if (pause !== true) {\n        pause = state.paused || matchProp(pause, key);\n      }\n      delay = callProp(props.delay || 0, key);\n      if (pause) {\n        state.resumeQueue.add(onResume);\n        actions.pause();\n      } else {\n        actions.resume();\n        onResume();\n      }\n    }\n    function onPause() {\n      state.resumeQueue.add(onResume);\n      state.timeouts.delete(timeout);\n      timeout.cancel();\n      delay = timeout.time - raf.now();\n    }\n    function onResume() {\n      if (delay > 0) {\n        timeout = raf.setTimeout(onStart, delay);\n        state.pauseQueue.add(onPause);\n        state.timeouts.add(timeout);\n      } else {\n        onStart();\n      }\n    }\n    function onStart() {\n      state.pauseQueue.delete(onPause);\n      state.timeouts.delete(timeout);\n      if (callId <= (state.cancelId || 0)) {\n        cancel = true;\n      }\n      try {\n        actions.start({...props, callId, cancel}, resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n}\n\nconst getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target) : results.every((result) => result.noop) ? getNoopResult(target) : getFinishedResult(target, results.every((result) => result.finished));\nconst getNoopResult = (target, value = target.get()) => ({\n  value,\n  noop: true,\n  finished: true,\n  target\n});\nconst getFinishedResult = (target, finished, value = target.get()) => ({\n  value,\n  finished,\n  target\n});\nconst getCancelledResult = (target, value = target.get()) => ({\n  value,\n  cancelled: true,\n  target\n});\n\nfunction runAsync(to, props, state, target) {\n  const {callId, parentId, onRest} = props;\n  const {asyncTo: prevTo, promise: prevPromise} = state;\n  if (!parentId && to === prevTo && !props.reset) {\n    return prevPromise;\n  }\n  return state.promise = (async () => {\n    state.asyncId = callId;\n    state.asyncTo = to;\n    const defaultProps = getDefaultProps(props, (value, key) => key === \"onRest\" ? void 0 : value);\n    let preventBail;\n    let bail;\n    const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject));\n    const bailIfEnded = (bailSignal) => {\n      const bailResult = callId <= (state.cancelId || 0) && getCancelledResult(target) || callId !== state.asyncId && getFinishedResult(target, false);\n      if (bailResult) {\n        bailSignal.result = bailResult;\n        bail(bailSignal);\n        throw bailSignal;\n      }\n    };\n    const animate = (arg1, arg2) => {\n      const bailSignal = new BailSignal();\n      return (async () => {\n        bailIfEnded(bailSignal);\n        const props2 = is.obj(arg1) ? {...arg1} : {...arg2, to: arg1};\n        props2.parentId = callId;\n        eachProp(defaultProps, (value, key) => {\n          if (is.und(props2[key])) {\n            props2[key] = value;\n          }\n        });\n        const result2 = await target.start(props2);\n        bailIfEnded(bailSignal);\n        if (state.paused) {\n          await new Promise((resume) => {\n            state.resumeQueue.add(resume);\n          });\n        }\n        return result2;\n      })();\n    };\n    let result;\n    try {\n      let animating;\n      if (is.arr(to)) {\n        animating = (async (queue) => {\n          for (const props2 of queue) {\n            await animate(props2);\n          }\n        })(to);\n      } else {\n        animating = Promise.resolve(to(animate, target.stop.bind(target)));\n      }\n      await Promise.all([animating.then(preventBail), bailPromise]);\n      result = getFinishedResult(target, true);\n    } catch (err) {\n      if (err instanceof BailSignal) {\n        result = err.result;\n      } else {\n        throw err;\n      }\n    } finally {\n      if (callId == state.asyncId) {\n        state.asyncId = parentId;\n        state.asyncTo = parentId ? prevTo : void 0;\n        state.promise = parentId ? prevPromise : void 0;\n      }\n    }\n    if (is.fun(onRest)) {\n      raf.batchedUpdates(() => {\n        onRest(result);\n      });\n    }\n    return result;\n  })();\n}\nfunction stopAsync(state, cancelId) {\n  flush(state.timeouts, (t) => t.cancel());\n  state.pauseQueue.clear();\n  state.resumeQueue.clear();\n  state.asyncId = state.asyncTo = state.promise = void 0;\n  if (cancelId)\n    state.cancelId = cancelId;\n}\nclass BailSignal extends Error {\n  constructor() {\n    super(\"An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.\");\n  }\n}\n\nconst isFrameValue = (value) => value instanceof FrameValue;\nlet nextId = 1;\nclass FrameValue extends FluidValue {\n  constructor() {\n    super(...arguments);\n    this.id = nextId++;\n    this._priority = 0;\n  }\n  get priority() {\n    return this._priority;\n  }\n  set priority(priority) {\n    if (this._priority != priority) {\n      this._priority = priority;\n      this._onPriorityChange(priority);\n    }\n  }\n  get() {\n    const node = getAnimated(this);\n    return node && node.getValue();\n  }\n  to(...args) {\n    return Globals.to(this, args);\n  }\n  interpolate(...args) {\n    deprecateInterpolate();\n    return Globals.to(this, args);\n  }\n  toJSON() {\n    return this.get();\n  }\n  observerAdded(count) {\n    if (count == 1)\n      this._attach();\n  }\n  observerRemoved(count) {\n    if (count == 0)\n      this._detach();\n  }\n  _attach() {\n  }\n  _detach() {\n  }\n  _onChange(value, idle = false) {\n    callFluidObservers(this, {\n      type: \"change\",\n      parent: this,\n      value,\n      idle\n    });\n  }\n  _onPriorityChange(priority) {\n    if (!this.idle) {\n      frameLoop.sort(this);\n    }\n    callFluidObservers(this, {\n      type: \"priority\",\n      parent: this,\n      priority\n    });\n  }\n}\n\nconst $P = Symbol.for(\"SpringPhase\");\nconst HAS_ANIMATED = 1;\nconst IS_ANIMATING = 2;\nconst IS_PAUSED = 4;\nconst hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;\nconst isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;\nconst isPaused = (target) => (target[$P] & IS_PAUSED) > 0;\nconst setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;\nconst setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;\n\nclass SpringValue extends FrameValue {\n  constructor(arg1, arg2) {\n    super();\n    this.animation = new Animation();\n    this.defaultProps = {};\n    this._state = {\n      paused: false,\n      pauseQueue: new Set(),\n      resumeQueue: new Set(),\n      timeouts: new Set()\n    };\n    this._pendingCalls = new Set();\n    this._lastCallId = 0;\n    this._lastToId = 0;\n    if (!is.und(arg1) || !is.und(arg2)) {\n      const props = is.obj(arg1) ? {...arg1} : {...arg2, from: arg1};\n      if (is.und(props.default)) {\n        props.default = true;\n      }\n      this.start(props);\n    }\n  }\n  get idle() {\n    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);\n  }\n  get goal() {\n    return getFluidValue(this.animation.to);\n  }\n  get velocity() {\n    const node = getAnimated(this);\n    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);\n  }\n  get hasAnimated() {\n    return hasAnimated(this);\n  }\n  get isAnimating() {\n    return isAnimating(this);\n  }\n  get isPaused() {\n    return isPaused(this);\n  }\n  advance(dt) {\n    let idle = true;\n    let changed = false;\n    const anim = this.animation;\n    let {config, toValues} = anim;\n    const payload = getPayload(anim.to);\n    if (!payload && hasFluidValue(anim.to)) {\n      toValues = toArray(getFluidValue(anim.to));\n    }\n    anim.values.forEach((node2, i) => {\n      if (node2.done)\n        return;\n      const to = node2.constructor == AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i];\n      let finished = anim.immediate;\n      let position = to;\n      if (!finished) {\n        position = node2.lastPosition;\n        if (config.tension <= 0) {\n          node2.done = true;\n          return;\n        }\n        const elapsed = node2.elapsedTime += dt;\n        const from = anim.fromValues[i];\n        const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n        let velocity;\n        if (!is.und(config.duration)) {\n          let p = 1;\n          if (config.duration > 0) {\n            p = (config.progress || 0) + elapsed / config.duration;\n            p = p > 1 ? 1 : p < 0 ? 0 : p;\n          }\n          position = from + config.easing(p) * (to - from);\n          velocity = (position - node2.lastPosition) / dt;\n          finished = p == 1;\n        } else if (config.decay) {\n          const decay = config.decay === true ? 0.998 : config.decay;\n          const e = Math.exp(-(1 - decay) * elapsed);\n          position = from + v0 / (1 - decay) * (1 - e);\n          finished = Math.abs(node2.lastPosition - position) < 0.1;\n          velocity = v0 * e;\n        } else {\n          velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;\n          const precision = config.precision || (from == to ? 5e-3 : Math.min(1, Math.abs(to - from) * 1e-3));\n          const restVelocity = config.restVelocity || precision / 10;\n          const bounceFactor = config.clamp ? 0 : config.bounce;\n          const canBounce = !is.und(bounceFactor);\n          const isGrowing = from == to ? node2.v0 > 0 : from < to;\n          let isMoving;\n          let isBouncing = false;\n          const step = 1;\n          const numSteps = Math.ceil(dt / step);\n          for (let n = 0; n < numSteps; ++n) {\n            isMoving = Math.abs(velocity) > restVelocity;\n            if (!isMoving) {\n              finished = Math.abs(to - position) <= precision;\n              if (finished) {\n                break;\n              }\n            }\n            if (canBounce) {\n              isBouncing = position == to || position > to == isGrowing;\n              if (isBouncing) {\n                velocity = -velocity * bounceFactor;\n                position = to;\n              }\n            }\n            const springForce = -config.tension * 1e-6 * (position - to);\n            const dampingForce = -config.friction * 1e-3 * velocity;\n            const acceleration = (springForce + dampingForce) / config.mass;\n            velocity = velocity + acceleration * step;\n            position = position + velocity * step;\n          }\n        }\n        node2.lastVelocity = velocity;\n        if (Number.isNaN(position)) {\n          console.warn(`Got NaN while animating:`, this);\n          finished = true;\n        }\n      }\n      if (payload && !payload[i].done) {\n        finished = false;\n      }\n      if (finished) {\n        node2.done = true;\n      } else {\n        idle = false;\n      }\n      if (node2.setValue(position, config.round)) {\n        changed = true;\n      }\n    });\n    const node = getAnimated(this);\n    if (idle) {\n      const value = getFluidValue(anim.to);\n      if (node.setValue(value) || changed) {\n        this._onChange(value);\n      }\n      this._stop();\n    } else if (changed) {\n      this._onChange(node.getValue());\n    }\n  }\n  set(value) {\n    raf.batchedUpdates(() => {\n      this._stop();\n      this._focus(value);\n      this._set(value);\n    });\n    return this;\n  }\n  pause() {\n    this._update({pause: true});\n  }\n  resume() {\n    this._update({pause: false});\n  }\n  finish() {\n    if (isAnimating(this)) {\n      const {to, config} = this.animation;\n      raf.batchedUpdates(() => {\n        this._onStart();\n        if (!config.decay) {\n          this._set(to, false);\n        }\n        this._stop();\n      });\n    }\n    return this;\n  }\n  update(props) {\n    const queue = this.queue || (this.queue = []);\n    queue.push(props);\n    return this;\n  }\n  start(to, arg2) {\n    let queue;\n    if (!is.und(to)) {\n      queue = [is.obj(to) ? to : {...arg2, to}];\n    } else {\n      queue = this.queue || [];\n      this.queue = [];\n    }\n    return Promise.all(queue.map((props) => this._update(props))).then((results) => getCombinedResult(this, results));\n  }\n  stop(cancel) {\n    const {to} = this.animation;\n    this._focus(this.get());\n    stopAsync(this._state, cancel && this._lastCallId);\n    raf.batchedUpdates(() => this._stop(to, cancel));\n    return this;\n  }\n  reset() {\n    this._update({reset: true});\n  }\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      this._start();\n    } else if (event.type == \"priority\") {\n      this.priority = event.priority + 1;\n    }\n  }\n  _prepareNode(props) {\n    const key = this.key || \"\";\n    let {to, from} = props;\n    to = is.obj(to) ? to[key] : to;\n    if (to == null || isAsyncTo(to)) {\n      to = void 0;\n    }\n    from = is.obj(from) ? from[key] : from;\n    if (from == null) {\n      from = void 0;\n    }\n    const range = {to, from};\n    if (!hasAnimated(this)) {\n      if (props.reverse)\n        [to, from] = [from, to];\n      from = getFluidValue(from);\n      if (!is.und(from)) {\n        this._set(from);\n      } else if (!getAnimated(this)) {\n        this._set(to);\n      }\n    }\n    return range;\n  }\n  _update({...props}, isLoop) {\n    const {key, defaultProps} = this;\n    if (props.default)\n      Object.assign(defaultProps, getDefaultProps(props, (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value));\n    mergeActiveFn(this, props, \"onProps\");\n    sendEvent(this, \"onProps\", props, this);\n    const range = this._prepareNode(props);\n    if (Object.isFrozen(this)) {\n      throw Error(\"Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?\");\n    }\n    const state = this._state;\n    return scheduleProps(++this._lastCallId, {\n      key,\n      props,\n      defaultProps,\n      state,\n      actions: {\n        pause: () => {\n          if (!isPaused(this)) {\n            setPausedBit(this, true);\n            flushCalls(state.pauseQueue);\n            sendEvent(this, \"onPause\", this);\n          }\n        },\n        resume: () => {\n          if (isPaused(this)) {\n            setPausedBit(this, false);\n            if (isAnimating(this)) {\n              this._resume();\n            }\n            flushCalls(state.resumeQueue);\n            sendEvent(this, \"onResume\", this);\n          }\n        },\n        start: this._merge.bind(this, range)\n      }\n    }).then((result) => {\n      if (props.loop && result.finished && !(isLoop && result.noop)) {\n        const nextProps = createLoopUpdate(props);\n        if (nextProps) {\n          return this._update(nextProps, true);\n        }\n      }\n      return result;\n    });\n  }\n  _merge(range, props, resolve) {\n    if (props.cancel) {\n      this.stop(true);\n      return resolve(getCancelledResult(this));\n    }\n    const hasToProp = !is.und(range.to);\n    const hasFromProp = !is.und(range.from);\n    if (hasToProp || hasFromProp) {\n      if (props.callId > this._lastToId) {\n        this._lastToId = props.callId;\n      } else {\n        return resolve(getCancelledResult(this));\n      }\n    }\n    const {key, defaultProps, animation: anim} = this;\n    const {to: prevTo, from: prevFrom} = anim;\n    let {to = prevTo, from = prevFrom} = range;\n    if (hasFromProp && !hasToProp && (!props.default || is.und(to))) {\n      to = from;\n    }\n    if (props.reverse)\n      [to, from] = [from, to];\n    const hasFromChanged = !isEqual(from, prevFrom);\n    if (hasFromChanged) {\n      anim.from = from;\n    }\n    from = getFluidValue(from);\n    const hasToChanged = !isEqual(to, prevTo);\n    if (hasToChanged) {\n      this._focus(to);\n    }\n    const hasAsyncTo = isAsyncTo(props.to);\n    const {config} = anim;\n    const {decay, velocity} = config;\n    if (hasToProp || hasFromProp) {\n      config.velocity = 0;\n    }\n    if (props.config && !hasAsyncTo) {\n      mergeConfig(config, callProp(props.config, key), props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);\n    }\n    let node = getAnimated(this);\n    if (!node || is.und(to)) {\n      return resolve(getFinishedResult(this, true));\n    }\n    const reset = is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key);\n    const value = reset ? from : this.get();\n    const goal = computeGoal(to);\n    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);\n    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));\n    if (hasToChanged) {\n      const nodeType = getAnimatedType(to);\n      if (nodeType !== node.constructor) {\n        if (immediate) {\n          node = this._set(goal);\n        } else\n          throw Error(`Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the \"to\" prop suggests`);\n      }\n    }\n    const goalType = node.constructor;\n    let started = hasFluidValue(to);\n    let finished = false;\n    if (!started) {\n      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;\n      if (hasToChanged || hasValueChanged) {\n        finished = isEqual(computeGoal(value), goal);\n        started = !finished;\n      }\n      if (!isEqual(config.decay, decay) || !isEqual(config.velocity, velocity)) {\n        started = true;\n      }\n    }\n    if (finished && isAnimating(this)) {\n      if (anim.changed && !reset) {\n        started = true;\n      } else if (!started) {\n        this._stop(prevTo);\n      }\n    }\n    if (!hasAsyncTo) {\n      if (started || hasFluidValue(prevTo)) {\n        anim.values = node.getPayload();\n        anim.toValues = hasFluidValue(to) ? null : goalType == AnimatedString ? [1] : toArray(goal);\n      }\n      if (anim.immediate != immediate) {\n        anim.immediate = immediate;\n        if (!immediate && !reset) {\n          this._set(prevTo);\n        }\n      }\n      if (started) {\n        const {onRest} = anim;\n        each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));\n        const result = getFinishedResult(this, checkFinished(this, prevTo));\n        flushCalls(this._pendingCalls, result);\n        this._pendingCalls.add(resolve);\n        if (anim.changed)\n          raf.batchedUpdates(() => {\n            var _a;\n            anim.changed = !reset;\n            onRest == null ? void 0 : onRest(result);\n            if (reset) {\n              callProp(defaultProps.onRest, result);\n            } else {\n              (_a = anim.onStart) == null ? void 0 : _a.call(anim, this);\n            }\n          });\n      }\n    }\n    if (reset) {\n      this._set(value);\n    }\n    if (hasAsyncTo) {\n      resolve(runAsync(props.to, props, this._state, this));\n    } else if (started) {\n      this._start();\n    } else if (isAnimating(this) && !hasToChanged) {\n      this._pendingCalls.add(resolve);\n    } else {\n      resolve(getNoopResult(this, value));\n    }\n  }\n  _focus(value) {\n    const anim = this.animation;\n    if (value !== anim.to) {\n      if (getFluidObservers(this)) {\n        this._detach();\n      }\n      anim.to = value;\n      if (getFluidObservers(this)) {\n        this._attach();\n      }\n    }\n  }\n  _attach() {\n    let priority = 0;\n    const {to} = this.animation;\n    if (hasFluidValue(to)) {\n      addFluidObserver(to, this);\n      if (isFrameValue(to)) {\n        priority = to.priority + 1;\n      }\n    }\n    this.priority = priority;\n  }\n  _detach() {\n    const {to} = this.animation;\n    if (hasFluidValue(to)) {\n      removeFluidObserver(to, this);\n    }\n  }\n  _set(arg, idle = true) {\n    const value = getFluidValue(arg);\n    if (!is.und(value)) {\n      const oldNode = getAnimated(this);\n      if (!oldNode || !isEqual(value, oldNode.getValue())) {\n        const nodeType = getAnimatedType(value);\n        if (!oldNode || oldNode.constructor != nodeType) {\n          setAnimated(this, nodeType.create(value));\n        } else {\n          oldNode.setValue(value);\n        }\n        if (oldNode) {\n          raf.batchedUpdates(() => {\n            this._onChange(value, idle);\n          });\n        }\n      }\n    }\n    return getAnimated(this);\n  }\n  _onStart() {\n    const anim = this.animation;\n    if (!anim.changed) {\n      anim.changed = true;\n      sendEvent(this, \"onStart\", this);\n    }\n  }\n  _onChange(value, idle) {\n    if (!idle) {\n      this._onStart();\n      callProp(this.animation.onChange, value, this);\n    }\n    callProp(this.defaultProps.onChange, value, this);\n    super._onChange(value, idle);\n  }\n  _start() {\n    const anim = this.animation;\n    getAnimated(this).reset(getFluidValue(anim.to));\n    if (!anim.immediate) {\n      anim.fromValues = anim.values.map((node) => node.lastPosition);\n    }\n    if (!isAnimating(this)) {\n      setActiveBit(this, true);\n      if (!isPaused(this)) {\n        this._resume();\n      }\n    }\n  }\n  _resume() {\n    if (Globals.skipAnimation) {\n      this.finish();\n    } else {\n      frameLoop.start(this);\n    }\n  }\n  _stop(goal, cancel) {\n    if (isAnimating(this)) {\n      setActiveBit(this, false);\n      const anim = this.animation;\n      each(anim.values, (node) => {\n        node.done = true;\n      });\n      if (anim.toValues) {\n        anim.onChange = anim.onPause = anim.onResume = void 0;\n      }\n      callFluidObservers(this, {\n        type: \"idle\",\n        parent: this\n      });\n      const result = cancel ? getCancelledResult(this) : getFinishedResult(this, checkFinished(this, goal != null ? goal : anim.to));\n      flushCalls(this._pendingCalls, result);\n      if (anim.changed) {\n        anim.changed = false;\n        sendEvent(this, \"onRest\", result);\n      }\n    }\n  }\n}\nfunction checkFinished(target, to) {\n  const goal = computeGoal(to);\n  const value = computeGoal(target.get());\n  return isEqual(value, goal);\n}\nfunction createLoopUpdate(props, loop = props.loop, to = props.to) {\n  let loopRet = callProp(loop);\n  if (loopRet) {\n    const overrides = loopRet !== true && inferTo(loopRet);\n    const reverse = (overrides || props).reverse;\n    const reset = !overrides || overrides.reset;\n    return createUpdate({\n      ...props,\n      loop,\n      default: false,\n      pause: void 0,\n      to: !reverse || isAsyncTo(to) ? to : void 0,\n      from: reset ? props.from : void 0,\n      reset,\n      ...overrides\n    });\n  }\n}\nfunction createUpdate(props) {\n  const {to, from} = props = inferTo(props);\n  const keys = new Set();\n  if (is.obj(to))\n    findDefined(to, keys);\n  if (is.obj(from))\n    findDefined(from, keys);\n  props.keys = keys.size ? Array.from(keys) : null;\n  return props;\n}\nfunction declareUpdate(props) {\n  const update = createUpdate(props);\n  if (is.und(update.default)) {\n    update.default = getDefaultProps(update);\n  }\n  return update;\n}\nfunction findDefined(values, keys) {\n  eachProp(values, (value, key) => value != null && keys.add(key));\n}\nconst ACTIVE_EVENTS = [\n  \"onStart\",\n  \"onRest\",\n  \"onChange\",\n  \"onPause\",\n  \"onResume\"\n];\nfunction mergeActiveFn(target, props, type) {\n  target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;\n}\nfunction sendEvent(target, type, ...args) {\n  var _a, _b, _c, _d;\n  (_b = (_a = target.animation)[type]) == null ? void 0 : _b.call(_a, ...args);\n  (_d = (_c = target.defaultProps)[type]) == null ? void 0 : _d.call(_c, ...args);\n}\n\nconst BATCHED_EVENTS = [\"onStart\", \"onChange\", \"onRest\"];\nlet nextId$1 = 1;\nclass Controller {\n  constructor(props, flush2) {\n    this.id = nextId$1++;\n    this.springs = {};\n    this.queue = [];\n    this._lastAsyncId = 0;\n    this._active = new Set();\n    this._changed = new Set();\n    this._started = false;\n    this._state = {\n      paused: false,\n      pauseQueue: new Set(),\n      resumeQueue: new Set(),\n      timeouts: new Set()\n    };\n    this._events = {\n      onStart: new Set(),\n      onChange: new Set(),\n      onRest: new Map()\n    };\n    this._onFrame = this._onFrame.bind(this);\n    if (flush2) {\n      this._flush = flush2;\n    }\n    if (props) {\n      this.start({default: true, ...props});\n    }\n  }\n  get idle() {\n    return !this._state.asyncTo && Object.values(this.springs).every((spring) => spring.idle);\n  }\n  get() {\n    const values = {};\n    this.each((spring, key) => values[key] = spring.get());\n    return values;\n  }\n  set(values) {\n    for (const key in values) {\n      const value = values[key];\n      if (!is.und(value)) {\n        this.springs[key].set(value);\n      }\n    }\n  }\n  update(props) {\n    if (props) {\n      this.queue.push(createUpdate(props));\n    }\n    return this;\n  }\n  start(props) {\n    let {queue} = this;\n    if (props) {\n      queue = toArray(props).map(createUpdate);\n    } else {\n      this.queue = [];\n    }\n    if (this._flush) {\n      return this._flush(this, queue);\n    }\n    prepareKeys(this, queue);\n    return flushUpdateQueue(this, queue);\n  }\n  stop(arg, keys) {\n    if (arg !== !!arg) {\n      keys = arg;\n    }\n    if (keys) {\n      const springs = this.springs;\n      each(toArray(keys), (key) => springs[key].stop(!!arg));\n    } else {\n      stopAsync(this._state, this._lastAsyncId);\n      this.each((spring) => spring.stop(!!arg));\n    }\n    return this;\n  }\n  pause(keys) {\n    if (is.und(keys)) {\n      this.start({pause: true});\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), (key) => springs[key].pause());\n    }\n    return this;\n  }\n  resume(keys) {\n    if (is.und(keys)) {\n      this.start({pause: false});\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), (key) => springs[key].resume());\n    }\n    return this;\n  }\n  each(iterator) {\n    eachProp(this.springs, iterator);\n  }\n  _onFrame() {\n    const {onStart, onChange, onRest} = this._events;\n    const active = this._active.size > 0;\n    if (active && !this._started) {\n      this._started = true;\n      flushCalls(onStart, this);\n    }\n    const idle = !active && this._started;\n    const changed = this._changed.size > 0 && onChange.size;\n    const values = changed || idle && onRest.size ? this.get() : null;\n    if (changed) {\n      flushCalls(onChange, values);\n    }\n    if (idle) {\n      this._started = false;\n      flush(onRest, ([onRest2, result]) => {\n        result.value = values;\n        onRest2(result);\n      });\n    }\n  }\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      this._changed.add(event.parent);\n      if (!event.idle) {\n        this._active.add(event.parent);\n      }\n    } else if (event.type == \"idle\") {\n      this._active.delete(event.parent);\n    } else\n      return;\n    raf.onFrame(this._onFrame);\n  }\n}\nfunction flushUpdateQueue(ctrl, queue) {\n  return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then((results) => getCombinedResult(ctrl, results));\n}\nasync function flushUpdate(ctrl, props, isLoop) {\n  const {keys, to, from, loop, onRest, onResolve} = props;\n  const defaults = is.obj(props.default) && props.default;\n  if (loop) {\n    props.loop = false;\n  }\n  if (to === false)\n    props.to = null;\n  if (from === false)\n    props.from = null;\n  const asyncTo = is.arr(to) || is.fun(to) ? to : void 0;\n  if (asyncTo) {\n    props.to = void 0;\n    props.onRest = void 0;\n    if (defaults) {\n      defaults.onRest = void 0;\n    }\n  } else {\n    each(BATCHED_EVENTS, (key) => {\n      const handler = props[key];\n      if (is.fun(handler)) {\n        const queue = ctrl[\"_events\"][key];\n        if (queue instanceof Set) {\n          props[key] = () => queue.add(handler);\n        } else {\n          props[key] = ({finished, cancelled}) => {\n            const result2 = queue.get(handler);\n            if (result2) {\n              if (!finished)\n                result2.finished = false;\n              if (cancelled)\n                result2.cancelled = true;\n            } else {\n              queue.set(handler, {\n                target: ctrl,\n                value: null,\n                finished,\n                cancelled\n              });\n            }\n          };\n        }\n        if (defaults) {\n          defaults[key] = props[key];\n        }\n      }\n    });\n  }\n  const state = ctrl[\"_state\"];\n  if (props.pause === !state.paused) {\n    state.paused = props.pause;\n    flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);\n  } else if (state.paused) {\n    props.pause = true;\n  }\n  const promises = (keys || Object.keys(ctrl.springs)).map((key) => ctrl.springs[key].start(props));\n  const cancel = props.cancel === true || getDefaultProp(props, \"cancel\") === true;\n  if (asyncTo || cancel && state.asyncId) {\n    promises.push(scheduleProps(++ctrl[\"_lastAsyncId\"], {\n      props,\n      state,\n      actions: {\n        pause: noop,\n        resume: noop,\n        start(props2, resolve) {\n          if (cancel) {\n            stopAsync(state, ctrl[\"_lastAsyncId\"]);\n            resolve(getCancelledResult(ctrl));\n          } else {\n            props2.onRest = onRest;\n            resolve(runAsync(asyncTo, props2, state, ctrl));\n          }\n        }\n      }\n    }));\n  }\n  if (state.paused) {\n    await new Promise((resume) => {\n      state.resumeQueue.add(resume);\n    });\n  }\n  const result = getCombinedResult(ctrl, await Promise.all(promises));\n  if (loop && result.finished && !(isLoop && result.noop)) {\n    const nextProps = createLoopUpdate(props, loop, to);\n    if (nextProps) {\n      prepareKeys(ctrl, [nextProps]);\n      return flushUpdate(ctrl, nextProps, true);\n    }\n  }\n  if (onResolve) {\n    raf.batchedUpdates(() => onResolve(result));\n  }\n  return result;\n}\nfunction getSprings(ctrl, props) {\n  const springs = {...ctrl.springs};\n  if (props) {\n    each(toArray(props), (props2) => {\n      if (is.und(props2.keys)) {\n        props2 = createUpdate(props2);\n      }\n      if (!is.obj(props2.to)) {\n        props2 = {...props2, to: void 0};\n      }\n      prepareSprings(springs, props2, (key) => {\n        return createSpring(key);\n      });\n    });\n  }\n  return springs;\n}\nfunction setSprings(ctrl, springs) {\n  eachProp(springs, (spring, key) => {\n    if (!ctrl.springs[key]) {\n      ctrl.springs[key] = spring;\n      addFluidObserver(spring, ctrl);\n    }\n  });\n}\nfunction createSpring(key, observer) {\n  const spring = new SpringValue();\n  spring.key = key;\n  if (observer) {\n    addFluidObserver(spring, observer);\n  }\n  return spring;\n}\nfunction prepareSprings(springs, props, create) {\n  if (props.keys) {\n    each(props.keys, (key) => {\n      const spring = springs[key] || (springs[key] = create(key));\n      spring[\"_prepareNode\"](props);\n    });\n  }\n}\nfunction prepareKeys(ctrl, queue) {\n  each(queue, (props) => {\n    prepareSprings(ctrl.springs, props, (key) => {\n      return createSpring(key, ctrl);\n    });\n  });\n}\n\nconst SpringContext = ({\n  children,\n  ...props\n}) => {\n  const inherited = useContext(ctx);\n  const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;\n  props = useMemoOne(() => ({pause, immediate}), [pause, immediate]);\n  const {Provider} = ctx;\n  return /* @__PURE__ */ createElement(Provider, {\n    value: props\n  }, children);\n};\nconst ctx = makeContext(SpringContext, {});\nSpringContext.Provider = ctx.Provider;\nSpringContext.Consumer = ctx.Consumer;\nfunction makeContext(target, init) {\n  Object.assign(target, createContext(init));\n  target.Provider._context = target;\n  target.Consumer._context = target;\n  return target;\n}\n\nclass SpringRef {\n  constructor() {\n    this.current = [];\n  }\n  set(values) {\n    each(this.current, (ctrl) => ctrl.set(values));\n  }\n  start(props) {\n    const results = [];\n    each(this.current, (ctrl, i) => {\n      if (is.und(props)) {\n        results.push(ctrl.start());\n      } else {\n        const update = this._getProps(props, ctrl, i);\n        if (update) {\n          results.push(ctrl.start(update));\n        }\n      }\n    });\n    return results;\n  }\n  update(props) {\n    each(this.current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));\n    return this;\n  }\n  add(ctrl) {\n    if (!this.current.includes(ctrl)) {\n      this.current.push(ctrl);\n    }\n  }\n  delete(ctrl) {\n    const i = this.current.indexOf(ctrl);\n    if (~i)\n      this.current.splice(i, 1);\n  }\n  _getProps(arg, ctrl, index) {\n    return is.fun(arg) ? arg(index, ctrl) : arg;\n  }\n}\neach([\"stop\", \"pause\", \"resume\"], (key) => {\n  SpringRef.prototype[key] = function() {\n    each(this.current, (ctrl) => ctrl[key](...arguments));\n    return this;\n  };\n});\n\nfunction useSprings(length, props, deps) {\n  const propsFn = is.fun(props) && props;\n  if (propsFn && !deps)\n    deps = [];\n  const ref = useMemo(() => propsFn || arguments.length == 3 ? new SpringRef() : void 0, []);\n  const layoutId = useRef(0);\n  const forceUpdate = useForceUpdate();\n  const state = useMemo(() => ({\n    ctrls: [],\n    queue: [],\n    flush(ctrl, updates2) {\n      const springs2 = getSprings(ctrl, updates2);\n      const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);\n      return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {\n        setSprings(ctrl, springs2);\n        state.queue.push(() => {\n          resolve(flushUpdateQueue(ctrl, updates2));\n        });\n        forceUpdate();\n      });\n    }\n  }), []);\n  const ctrls = [...state.ctrls];\n  const updates = [];\n  const prevLength = usePrev(length) || 0;\n  const oldCtrls = ctrls.slice(length, prevLength);\n  useMemo(() => {\n    ctrls.length = length;\n    declareUpdates(prevLength, length);\n  }, [length]);\n  useMemo(() => {\n    declareUpdates(0, Math.min(prevLength, length));\n  }, deps);\n  function declareUpdates(startIndex, endIndex) {\n    for (let i = startIndex; i < endIndex; i++) {\n      const ctrl = ctrls[i] || (ctrls[i] = new Controller(null, state.flush));\n      const update = propsFn ? propsFn(i, ctrl) : props[i];\n      if (update) {\n        updates[i] = declareUpdate(update);\n      }\n    }\n  }\n  const springs = ctrls.map((ctrl, i) => getSprings(ctrl, updates[i]));\n  const context = useContext(SpringContext);\n  const prevContext = usePrev(context);\n  const hasContext = context !== prevContext && hasProps(context);\n  useLayoutEffect(() => {\n    layoutId.current++;\n    state.ctrls = ctrls;\n    const {queue} = state;\n    if (queue.length) {\n      state.queue = [];\n      each(queue, (cb) => cb());\n    }\n    each(oldCtrls, (ctrl) => {\n      detachRefs(ctrl, ref);\n      ctrl.stop(true);\n    });\n    each(ctrls, (ctrl, i) => {\n      const values2 = springs[i];\n      setSprings(ctrl, values2);\n      ref == null ? void 0 : ref.add(ctrl);\n      if (hasContext) {\n        ctrl.start({default: context});\n      }\n      const update = updates[i];\n      if (update) {\n        replaceRef(ctrl, update.ref);\n        if (ctrl.ref) {\n          ctrl.queue.push(update);\n        } else {\n          ctrl.start(update);\n        }\n      }\n    });\n  });\n  useOnce(() => () => {\n    each(state.ctrls, (ctrl) => ctrl.stop(true));\n  });\n  const values = springs.map((x) => ({...x}));\n  return ref ? [values, ref] : values;\n}\n\nfunction useSpring(props, deps) {\n  const isFn = is.fun(props);\n  const [[values], ref] = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps);\n  return isFn || arguments.length == 2 ? [values, ref] : values;\n}\n\nconst initSpringRef = () => new SpringRef();\nconst useSpringRef = () => useState(initSpringRef)[0];\n\nfunction useTrail(length, propsArg, deps) {\n  const propsFn = is.fun(propsArg) && propsArg;\n  if (propsFn && !deps)\n    deps = [];\n  let reverse = true;\n  const result = useSprings(length, (i, ctrl) => {\n    const props = propsFn ? propsFn(i, ctrl) : propsArg;\n    reverse = reverse && props.reverse;\n    return props;\n  }, deps || [{}]);\n  const ref = result[1];\n  useLayoutEffect(() => {\n    each(ref.current, (ctrl, i) => {\n      const parent = ref.current[i + (reverse ? 1 : -1)];\n      if (parent)\n        ctrl.start({to: parent.springs});\n    });\n  }, deps);\n  if (propsFn || arguments.length == 3) {\n    ref[\"_getProps\"] = (propsArg2, ctrl, i) => {\n      const props = is.fun(propsArg2) ? propsArg2(i, ctrl) : propsArg2;\n      if (props) {\n        const parent = ref.current[i + (props.reverse ? 1 : -1)];\n        if (parent)\n          props.to = parent.springs;\n        return props;\n      }\n    };\n    return result;\n  }\n  return result[0];\n}\n\nconst MOUNT = \"mount\";\nconst ENTER = \"enter\";\nconst UPDATE = \"update\";\nconst LEAVE = \"leave\";\n\nfunction useTransition(data, props, deps) {\n  const {reset, sort, trail = 0, expires = true, onDestroyed} = props;\n  const ref = useMemo(() => arguments.length == 3 ? new SpringRef() : void 0, []);\n  const items = toArray(data);\n  const transitions = [];\n  const usedTransitions = useRef(null);\n  const prevTransitions = reset ? null : usedTransitions.current;\n  useLayoutEffect(() => {\n    usedTransitions.current = transitions;\n  });\n  useOnce(() => () => each(usedTransitions.current, (t) => {\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n    }\n    detachRefs(t.ctrl, ref);\n    t.ctrl.stop(true);\n  }));\n  const keys = getKeys(items, props, prevTransitions);\n  const expired = reset && usedTransitions.current || [];\n  useLayoutEffect(() => each(expired, ({ctrl, item, key}) => {\n    detachRefs(ctrl, ref);\n    callProp(onDestroyed, item, key);\n  }));\n  const reused = [];\n  if (prevTransitions)\n    each(prevTransitions, (t, i) => {\n      if (t.expired) {\n        clearTimeout(t.expirationId);\n        expired.push(t);\n      } else {\n        i = reused[i] = keys.indexOf(t.key);\n        if (~i)\n          transitions[i] = t;\n      }\n    });\n  each(items, (item, i) => {\n    transitions[i] || (transitions[i] = {\n      key: keys[i],\n      item,\n      phase: MOUNT,\n      ctrl: new Controller()\n    });\n  });\n  if (reused.length) {\n    let i = -1;\n    each(reused, (keyIndex, prevIndex) => {\n      const t = prevTransitions[prevIndex];\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = {...t, item: items[keyIndex]};\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n  if (is.fun(sort)) {\n    transitions.sort((a, b) => sort(a.item, b.item));\n  }\n  let delay = -trail;\n  const forceUpdate = useForceUpdate();\n  const defaultProps = getDefaultProps(props);\n  const changes = new Map();\n  each(transitions, (t, i) => {\n    const key = t.key;\n    const prevPhase = t.phase;\n    let to;\n    let phase;\n    if (prevPhase == MOUNT) {\n      to = props.enter;\n      phase = ENTER;\n    } else {\n      const isLeave = keys.indexOf(key) < 0;\n      if (prevPhase != LEAVE) {\n        if (isLeave) {\n          to = props.leave;\n          phase = LEAVE;\n        } else if (to = props.update) {\n          phase = UPDATE;\n        } else\n          return;\n      } else if (!isLeave) {\n        to = props.enter;\n        phase = ENTER;\n      } else\n        return;\n    }\n    to = callProp(to, t.item, i);\n    to = is.obj(to) ? inferTo(to) : {to};\n    if (!to.config) {\n      const config = props.config || defaultProps.config;\n      to.config = callProp(config, t.item, i);\n    }\n    const payload = {\n      ...defaultProps,\n      delay: delay += trail,\n      reset: false,\n      ...to\n    };\n    if (phase == ENTER && is.und(payload.from)) {\n      const from = is.und(props.initial) || prevTransitions ? props.from : props.initial;\n      payload.from = callProp(from, t.item, i);\n    }\n    const {onResolve} = payload;\n    payload.onResolve = (result) => {\n      callProp(onResolve, result);\n      const transitions2 = usedTransitions.current;\n      const t2 = transitions2.find((t3) => t3.key === key);\n      if (!t2)\n        return;\n      if (result.cancelled && t2.phase != UPDATE) {\n        t2.phase = prevPhase;\n        return;\n      }\n      if (t2.ctrl.idle) {\n        const idle = transitions2.every((t3) => t3.ctrl.idle);\n        if (t2.phase == LEAVE) {\n          const expiry = callProp(expires, t2.item);\n          if (expiry !== false) {\n            const expiryMs = expiry === true ? 0 : expiry;\n            t2.expired = true;\n            if (!idle && expiryMs > 0) {\n              if (expiryMs <= 2147483647)\n                t2.expirationId = setTimeout(forceUpdate, expiryMs);\n              return;\n            }\n          }\n        }\n        if (idle && transitions2.some((t3) => t3.expired)) {\n          forceUpdate();\n        }\n      }\n    };\n    const springs = getSprings(t.ctrl, payload);\n    changes.set(t, {phase, springs, payload});\n  });\n  const context = useContext(SpringContext);\n  const prevContext = usePrev(context);\n  const hasContext = context !== prevContext && hasProps(context);\n  useLayoutEffect(() => {\n    if (hasContext)\n      each(transitions, (t) => {\n        t.ctrl.start({default: context});\n      });\n  }, [context]);\n  useLayoutEffect(() => {\n    each(changes, ({phase, springs, payload}, t) => {\n      const {ctrl} = t;\n      t.phase = phase;\n      ref == null ? void 0 : ref.add(ctrl);\n      replaceRef(ctrl, payload.ref);\n      setSprings(ctrl, springs);\n      if (hasContext && phase == ENTER) {\n        ctrl.start({default: context});\n      }\n      ctrl[ctrl.ref ? \"update\" : \"start\"](payload);\n    });\n  }, reset ? void 0 : deps);\n  const renderTransitions = (render) => /* @__PURE__ */ createElement(Fragment, null, transitions.map((t, i) => {\n    const {springs} = changes.get(t) || t.ctrl;\n    const elem = render({...springs}, t.item, t, i);\n    return elem && elem.type ? /* @__PURE__ */ createElement(elem.type, {\n      ...elem.props,\n      key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,\n      ref: elem.ref\n    }) : elem;\n  }));\n  return ref ? [renderTransitions, ref] : renderTransitions;\n}\nlet nextKey = 1;\nfunction getKeys(items, {key, keys = key}, prevTransitions) {\n  if (keys === null) {\n    const reused = new Set();\n    return items.map((item) => {\n      const t = prevTransitions && prevTransitions.find((t2) => t2.item === item && t2.phase !== LEAVE && !reused.has(t2));\n      if (t) {\n        reused.add(t);\n        return t.key;\n      }\n      return nextKey++;\n    });\n  }\n  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);\n}\n\nfunction Spring({children, ...props}) {\n  return children(useSpring(props));\n}\n\nfunction Trail({\n  items,\n  children,\n  ...props\n}) {\n  const trails = useTrail(items.length, props);\n  return items.map((item, index) => {\n    const result = children(item, index);\n    return is.fun(result) ? result(trails[index]) : result;\n  });\n}\n\nfunction Transition({\n  items,\n  children,\n  ...props\n}) {\n  return useTransition(items, props)(children);\n}\n\nclass Interpolation extends FrameValue {\n  constructor(source, args) {\n    super();\n    this.source = source;\n    this.idle = true;\n    this._active = new Set();\n    this.calc = createInterpolator(...args);\n    const value = this._get();\n    const nodeType = getAnimatedType(value);\n    setAnimated(this, nodeType.create(value));\n  }\n  advance(_dt) {\n    const value = this._get();\n    const oldValue = this.get();\n    if (!isEqual(value, oldValue)) {\n      getAnimated(this).setValue(value);\n      this._onChange(value, this.idle);\n    }\n    if (!this.idle && checkIdle(this._active)) {\n      becomeIdle(this);\n    }\n  }\n  _get() {\n    const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));\n    return this.calc(...inputs);\n  }\n  _start() {\n    if (this.idle && !checkIdle(this._active)) {\n      this.idle = false;\n      each(getPayload(this), (node) => {\n        node.done = false;\n      });\n      if (Globals.skipAnimation) {\n        raf.batchedUpdates(() => this.advance());\n        becomeIdle(this);\n      } else {\n        frameLoop.start(this);\n      }\n    }\n  }\n  _attach() {\n    let priority = 1;\n    each(toArray(this.source), (source) => {\n      if (hasFluidValue(source)) {\n        addFluidObserver(source, this);\n      }\n      if (isFrameValue(source)) {\n        if (!source.idle) {\n          this._active.add(source);\n        }\n        priority = Math.max(priority, source.priority + 1);\n      }\n    });\n    this.priority = priority;\n    this._start();\n  }\n  _detach() {\n    each(toArray(this.source), (source) => {\n      if (hasFluidValue(source)) {\n        removeFluidObserver(source, this);\n      }\n    });\n    this._active.clear();\n    becomeIdle(this);\n  }\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      if (event.idle) {\n        this.advance();\n      } else {\n        this._active.add(event.parent);\n        this._start();\n      }\n    } else if (event.type == \"idle\") {\n      this._active.delete(event.parent);\n    } else if (event.type == \"priority\") {\n      this.priority = toArray(this.source).reduce((highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1), 0);\n    }\n  }\n}\nfunction isIdle(source) {\n  return source.idle !== false;\n}\nfunction checkIdle(active) {\n  return !active.size || Array.from(active).every(isIdle);\n}\nfunction becomeIdle(self) {\n  if (!self.idle) {\n    self.idle = true;\n    each(getPayload(self), (node) => {\n      node.done = true;\n    });\n    callFluidObservers(self, {\n      type: \"idle\",\n      parent: self\n    });\n  }\n}\n\nconst to = (source, ...args) => new Interpolation(source, args);\nconst interpolate = (source, ...args) => (deprecateInterpolate(), new Interpolation(source, args));\n\nGlobals.assign({\n  createStringInterpolator,\n  to: (source, args) => new Interpolation(source, args)\n});\nconst update = frameLoop.advance;\n\nexport { BailSignal, Controller, FrameValue, Interpolation, Spring, SpringContext, SpringRef, SpringValue, Trail, Transition, config, inferTo, interpolate, to, update, useChain, useSpring, useSpringRef, useSprings, useTrail, useTransition };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}