{"ast":null,"code":"let updateQueue = makeQueue();\n\nconst raf = fn => schedule(fn, updateQueue);\n\nlet writeQueue = makeQueue();\n\nraf.write = fn => schedule(fn, writeQueue);\n\nlet onStartQueue = makeQueue();\n\nraf.onStart = fn => schedule(fn, onStartQueue);\n\nlet onFrameQueue = makeQueue();\n\nraf.onFrame = fn => schedule(fn, onFrameQueue);\n\nlet onFinishQueue = makeQueue();\n\nraf.onFinish = fn => schedule(fn, onFinishQueue);\n\nlet timeouts = [];\n\nraf.setTimeout = (handler, ms) => {\n  let time = raf.now() + ms;\n\n  let cancel = () => {\n    let i = timeouts.findIndex(t => t.cancel == cancel);\n    if (~i) timeouts.splice(i, 1);\n    __raf.count -= ~i ? 1 : 0;\n  };\n\n  let timeout = {\n    time,\n    handler,\n    cancel\n  };\n  timeouts.splice(findTimeout(time), 0, timeout);\n  __raf.count += 1;\n  start();\n  return timeout;\n};\n\nlet findTimeout = time => ~(~timeouts.findIndex(t => t.time > time) || ~timeouts.length);\n\nraf.cancel = fn => {\n  updateQueue.delete(fn);\n  writeQueue.delete(fn);\n};\n\nraf.sync = fn => {\n  sync = true;\n  raf.batchedUpdates(fn);\n  sync = false;\n};\n\nraf.throttle = fn => {\n  let lastArgs;\n\n  function queuedFn() {\n    try {\n      fn(...lastArgs);\n    } finally {\n      lastArgs = null;\n    }\n  }\n\n  function throttled() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    lastArgs = args;\n    raf.onStart(queuedFn);\n  }\n\n  throttled.handler = fn;\n\n  throttled.cancel = () => {\n    onStartQueue.delete(queuedFn);\n    lastArgs = null;\n  };\n\n  return throttled;\n};\n\nlet nativeRaf = typeof window != \"undefined\" ? window.requestAnimationFrame : () => {};\n\nraf.use = impl => nativeRaf = impl;\n\nraf.now = typeof performance != \"undefined\" ? () => performance.now() : Date.now;\n\nraf.batchedUpdates = fn => fn();\n\nraf.catch = console.error;\nlet ts = -1;\nlet sync = false;\n\nfunction schedule(fn, queue) {\n  if (sync) {\n    queue.delete(fn);\n    fn(0);\n  } else {\n    queue.add(fn);\n    start();\n  }\n}\n\nfunction start() {\n  if (ts < 0) {\n    ts = 0;\n    nativeRaf(loop);\n  }\n}\n\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop);\n    raf.batchedUpdates(update);\n  }\n}\n\nfunction update() {\n  let prevTs = ts;\n  ts = raf.now();\n  let count = findTimeout(ts);\n\n  if (count) {\n    eachSafely(timeouts.splice(0, count), t => t.handler());\n    __raf.count -= count;\n  }\n\n  onStartQueue.flush();\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);\n  onFrameQueue.flush();\n  writeQueue.flush();\n  onFinishQueue.flush();\n}\n\nfunction makeQueue() {\n  let next = new Set();\n  let current = next;\n  return {\n    add(fn) {\n      __raf.count += current == next && !next.has(fn) ? 1 : 0;\n      next.add(fn);\n    },\n\n    delete(fn) {\n      __raf.count -= current == next && next.has(fn) ? 1 : 0;\n      return next.delete(fn);\n    },\n\n    flush(arg) {\n      if (current.size) {\n        next = new Set();\n        __raf.count -= current.size;\n        eachSafely(current, fn => fn(arg) && next.add(fn));\n        __raf.count += next.size;\n        current = next;\n      }\n    }\n\n  };\n}\n\nfunction eachSafely(values, each) {\n  values.forEach(value => {\n    try {\n      each(value);\n    } catch (e) {\n      raf.catch(e);\n    }\n  });\n}\n\nconst __raf = {\n  count: 0,\n\n  clear() {\n    ts = -1;\n    timeouts = [];\n    onStartQueue = makeQueue();\n    updateQueue = makeQueue();\n    onFrameQueue = makeQueue();\n    writeQueue = makeQueue();\n    onFinishQueue = makeQueue();\n    __raf.count = 0;\n  }\n\n};\nexport { __raf, raf };","map":{"version":3,"sources":["../src/raf.ts"],"names":[],"mappings":"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","sourcesContent":["let updateQueue = makeQueue();\nconst raf = (fn) => schedule(fn, updateQueue);\nlet writeQueue = makeQueue();\nraf.write = (fn) => schedule(fn, writeQueue);\nlet onStartQueue = makeQueue();\nraf.onStart = (fn) => schedule(fn, onStartQueue);\nlet onFrameQueue = makeQueue();\nraf.onFrame = (fn) => schedule(fn, onFrameQueue);\nlet onFinishQueue = makeQueue();\nraf.onFinish = (fn) => schedule(fn, onFinishQueue);\nlet timeouts = [];\nraf.setTimeout = (handler, ms) => {\n  let time = raf.now() + ms;\n  let cancel = () => {\n    let i = timeouts.findIndex((t) => t.cancel == cancel);\n    if (~i)\n      timeouts.splice(i, 1);\n    __raf.count -= ~i ? 1 : 0;\n  };\n  let timeout = {time, handler, cancel};\n  timeouts.splice(findTimeout(time), 0, timeout);\n  __raf.count += 1;\n  start();\n  return timeout;\n};\nlet findTimeout = (time) => ~(~timeouts.findIndex((t) => t.time > time) || ~timeouts.length);\nraf.cancel = (fn) => {\n  updateQueue.delete(fn);\n  writeQueue.delete(fn);\n};\nraf.sync = (fn) => {\n  sync = true;\n  raf.batchedUpdates(fn);\n  sync = false;\n};\nraf.throttle = (fn) => {\n  let lastArgs;\n  function queuedFn() {\n    try {\n      fn(...lastArgs);\n    } finally {\n      lastArgs = null;\n    }\n  }\n  function throttled(...args) {\n    lastArgs = args;\n    raf.onStart(queuedFn);\n  }\n  throttled.handler = fn;\n  throttled.cancel = () => {\n    onStartQueue.delete(queuedFn);\n    lastArgs = null;\n  };\n  return throttled;\n};\nlet nativeRaf = typeof window != \"undefined\" ? window.requestAnimationFrame : () => {\n};\nraf.use = (impl) => nativeRaf = impl;\nraf.now = typeof performance != \"undefined\" ? () => performance.now() : Date.now;\nraf.batchedUpdates = (fn) => fn();\nraf.catch = console.error;\nlet ts = -1;\nlet sync = false;\nfunction schedule(fn, queue) {\n  if (sync) {\n    queue.delete(fn);\n    fn(0);\n  } else {\n    queue.add(fn);\n    start();\n  }\n}\nfunction start() {\n  if (ts < 0) {\n    ts = 0;\n    nativeRaf(loop);\n  }\n}\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop);\n    raf.batchedUpdates(update);\n  }\n}\nfunction update() {\n  let prevTs = ts;\n  ts = raf.now();\n  let count = findTimeout(ts);\n  if (count) {\n    eachSafely(timeouts.splice(0, count), (t) => t.handler());\n    __raf.count -= count;\n  }\n  onStartQueue.flush();\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);\n  onFrameQueue.flush();\n  writeQueue.flush();\n  onFinishQueue.flush();\n}\nfunction makeQueue() {\n  let next = new Set();\n  let current = next;\n  return {\n    add(fn) {\n      __raf.count += current == next && !next.has(fn) ? 1 : 0;\n      next.add(fn);\n    },\n    delete(fn) {\n      __raf.count -= current == next && next.has(fn) ? 1 : 0;\n      return next.delete(fn);\n    },\n    flush(arg) {\n      if (current.size) {\n        next = new Set();\n        __raf.count -= current.size;\n        eachSafely(current, (fn) => fn(arg) && next.add(fn));\n        __raf.count += next.size;\n        current = next;\n      }\n    }\n  };\n}\nfunction eachSafely(values, each) {\n  values.forEach((value) => {\n    try {\n      each(value);\n    } catch (e) {\n      raf.catch(e);\n    }\n  });\n}\nconst __raf = {\n  count: 0,\n  clear() {\n    ts = -1;\n    timeouts = [];\n    onStartQueue = makeQueue();\n    updateQueue = makeQueue();\n    onFrameQueue = makeQueue();\n    writeQueue = makeQueue();\n    onFinishQueue = makeQueue();\n    __raf.count = 0;\n  }\n};\n\nexport { __raf, raf };\n//# sourceMappingURL=raf.mjs.map\n"]},"metadata":{},"sourceType":"module"}