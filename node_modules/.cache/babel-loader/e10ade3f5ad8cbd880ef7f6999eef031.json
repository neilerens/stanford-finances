{"ast":null,"code":"import { defineHidden, is, createInterpolator, eachProp, hasFluidValue, getFluidValue, each, isAnimatedString, useForceUpdate, addFluidObserver, removeFluidObserver, raf, useOnce } from '@react-spring/shared';\nimport { forwardRef, useRef, useCallback, useEffect, createElement } from 'react';\nimport { useLayoutEffect } from 'react-layout-effect';\nconst $node = Symbol.for(\"Animated:node\");\n\nconst isAnimated = value => !!value && value[$node] === value;\n\nconst getAnimated = owner => owner && owner[$node];\n\nconst setAnimated = (owner, node) => defineHidden(owner, $node, node);\n\nconst getPayload = owner => owner && owner[$node] && owner[$node].getPayload();\n\nclass Animated {\n  constructor() {\n    setAnimated(this, this);\n  }\n\n  getPayload() {\n    return this.payload || [];\n  }\n\n}\n\nclass AnimatedValue extends Animated {\n  constructor(_value) {\n    super();\n    this._value = _value;\n    this.done = true;\n\n    if (is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n\n  static create(value) {\n    return new AnimatedValue(value);\n  }\n\n  getPayload() {\n    return [this];\n  }\n\n  getValue() {\n    return this._value;\n  }\n\n  setValue(value, step) {\n    if (is.num(value)) {\n      this.lastPosition = value;\n\n      if (step) {\n        value = Math.round(value / step) * step;\n\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n\n    if (this._value === value) {\n      return false;\n    }\n\n    this._value = value;\n    return true;\n  }\n\n  reset() {\n    const {\n      done\n    } = this;\n    this.done = false;\n\n    if (is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.lastPosition = this._value;\n      if (done) this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n\n}\n\nclass AnimatedString extends AnimatedValue {\n  constructor(value) {\n    super(0);\n    this._string = null;\n    this._toString = createInterpolator({\n      output: [value, value]\n    });\n  }\n\n  static create(value) {\n    return new AnimatedString(value);\n  }\n\n  getValue() {\n    let value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n\n  setValue(value) {\n    if (is.str(value)) {\n      if (value == this._string) {\n        return false;\n      }\n\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  reset(goal) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal]\n      });\n    }\n\n    this._value = 0;\n    super.reset();\n  }\n\n}\n\nconst TreeContext = {\n  dependencies: null\n};\n\nclass AnimatedObject extends Animated {\n  constructor(source) {\n    super();\n    this.source = source;\n    this.setValue(source);\n  }\n\n  getValue(animated) {\n    const values = {};\n    eachProp(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else if (hasFluidValue(source)) {\n        values[key] = getFluidValue(source);\n      } else if (!animated) {\n        values[key] = source;\n      }\n    });\n    return values;\n  }\n\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset());\n    }\n  }\n\n  _makePayload(source) {\n    if (source) {\n      const payload = new Set();\n      eachProp(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n\n  _addToPayload(source) {\n    if (TreeContext.dependencies && hasFluidValue(source)) {\n      TreeContext.dependencies.add(source);\n    }\n\n    const payload = getPayload(source);\n\n    if (payload) {\n      each(payload, node => this.add(node));\n    }\n  }\n\n}\n\nclass AnimatedArray extends AnimatedObject {\n  constructor(source) {\n    super(source);\n  }\n\n  static create(source) {\n    return new AnimatedArray(source);\n  }\n\n  getValue() {\n    return this.source.map(node => node.getValue());\n  }\n\n  setValue(source) {\n    const payload = this.getPayload();\n\n    if (source.length == payload.length) {\n      return payload.some((node, i) => node.setValue(source[i]));\n    }\n\n    super.setValue(source.map(makeAnimated));\n    return true;\n  }\n\n}\n\nfunction makeAnimated(value) {\n  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  return nodeType.create(value);\n}\n\nfunction getAnimatedType(value) {\n  const parentNode = getAnimated(value);\n  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;\n}\n\nconst withAnimated = (Component, host) => {\n  const hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  return forwardRef((givenProps, givenRef) => {\n    const instanceRef = useRef(null);\n    const ref = hasInstance && useCallback(value => {\n      instanceRef.current = updateRef(givenRef, value);\n    }, [givenRef]);\n    const [props, deps] = getAnimatedState(givenProps, host);\n    const forceUpdate = useForceUpdate();\n\n    const callback = () => {\n      const instance = instanceRef.current;\n\n      if (hasInstance && !instance) {\n        return;\n      }\n\n      const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;\n\n      if (didUpdate === false) {\n        forceUpdate();\n      }\n    };\n\n    const observer = new PropsObserver(callback, deps);\n    const observerRef = useRef();\n    useLayoutEffect(() => {\n      const lastObserver = observerRef.current;\n      observerRef.current = observer;\n      each(deps, dep => addFluidObserver(dep, observer));\n\n      if (lastObserver) {\n        each(lastObserver.deps, dep => removeFluidObserver(dep, lastObserver));\n        raf.cancel(lastObserver.update);\n      }\n    });\n    useEffect(callback, []);\n    useOnce(() => () => {\n      const observer2 = observerRef.current;\n      each(observer2.deps, dep => removeFluidObserver(dep, observer2));\n    });\n    const usedProps = host.getComponentProps(props.getValue());\n    return /* @__PURE__ */createElement(Component, { ...usedProps,\n      ref\n    });\n  });\n};\n\nclass PropsObserver {\n  constructor(update, deps) {\n    this.update = update;\n    this.deps = deps;\n  }\n\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      raf.write(this.update);\n    }\n  }\n\n}\n\nfunction getAnimatedState(props, host) {\n  const dependencies = new Set();\n  TreeContext.dependencies = dependencies;\n  if (props.style) props = { ...props,\n    style: host.createAnimatedStyle(props.style)\n  };\n  props = new AnimatedObject(props);\n  TreeContext.dependencies = null;\n  return [props, dependencies];\n}\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n}\n\nconst cacheKey = Symbol.for(\"AnimatedComponent\");\n\nconst createHost = function (components) {\n  let {\n    applyAnimatedValues = () => false,\n    createAnimatedStyle = style => new AnimatedObject(style),\n    getComponentProps = props => props\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const hostConfig = {\n    applyAnimatedValues,\n    createAnimatedStyle,\n    getComponentProps\n  };\n\n  const animated = Component => {\n    const displayName = getDisplayName(Component) || \"Anonymous\";\n\n    if (is.str(Component)) {\n      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n\n    Component.displayName = `Animated(${displayName})`;\n    return Component;\n  };\n\n  eachProp(components, (Component, key) => {\n    if (is.arr(components)) {\n      key = getDisplayName(Component);\n    }\n\n    animated[key] = animated(Component);\n  });\n  return {\n    animated\n  };\n};\n\nconst getDisplayName = arg => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedString, AnimatedValue, createHost, getAnimated, getAnimatedType, getPayload, isAnimated, setAnimated };","map":{"version":3,"sources":["src/Animated.ts","src/AnimatedValue.ts","src/AnimatedString.ts","src/context.ts","src/AnimatedObject.ts","src/AnimatedArray.ts","src/getAnimatedType.ts","src/withAnimated.tsx","src/createHost.ts"],"names":["AnimatedString2","AnimatedValue2","AnimatedArray2","AnimatedObject2","withAnimated2"],"mappings":"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","sourcesContent":["import { defineHidden, is, createInterpolator, eachProp, hasFluidValue, getFluidValue, each, isAnimatedString, useForceUpdate, addFluidObserver, removeFluidObserver, raf, useOnce } from '@react-spring/shared';\nimport { forwardRef, useRef, useCallback, useEffect, createElement } from 'react';\nimport { useLayoutEffect } from 'react-layout-effect';\n\nconst $node = Symbol.for(\"Animated:node\");\nconst isAnimated = (value) => !!value && value[$node] === value;\nconst getAnimated = (owner) => owner && owner[$node];\nconst setAnimated = (owner, node) => defineHidden(owner, $node, node);\nconst getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();\nclass Animated {\n  constructor() {\n    setAnimated(this, this);\n  }\n  getPayload() {\n    return this.payload || [];\n  }\n}\n\nclass AnimatedValue extends Animated {\n  constructor(_value) {\n    super();\n    this._value = _value;\n    this.done = true;\n    if (is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n  static create(value) {\n    return new AnimatedValue(value);\n  }\n  getPayload() {\n    return [this];\n  }\n  getValue() {\n    return this._value;\n  }\n  setValue(value, step) {\n    if (is.num(value)) {\n      this.lastPosition = value;\n      if (step) {\n        value = Math.round(value / step) * step;\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n    if (this._value === value) {\n      return false;\n    }\n    this._value = value;\n    return true;\n  }\n  reset() {\n    const {done} = this;\n    this.done = false;\n    if (is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.lastPosition = this._value;\n      if (done)\n        this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n}\n\nclass AnimatedString extends AnimatedValue {\n  constructor(value) {\n    super(0);\n    this._string = null;\n    this._toString = createInterpolator({\n      output: [value, value]\n    });\n  }\n  static create(value) {\n    return new AnimatedString(value);\n  }\n  getValue() {\n    let value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n  setValue(value) {\n    if (is.str(value)) {\n      if (value == this._string) {\n        return false;\n      }\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n    return true;\n  }\n  reset(goal) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal]\n      });\n    }\n    this._value = 0;\n    super.reset();\n  }\n}\n\nconst TreeContext = {dependencies: null};\n\nclass AnimatedObject extends Animated {\n  constructor(source) {\n    super();\n    this.source = source;\n    this.setValue(source);\n  }\n  getValue(animated) {\n    const values = {};\n    eachProp(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else if (hasFluidValue(source)) {\n        values[key] = getFluidValue(source);\n      } else if (!animated) {\n        values[key] = source;\n      }\n    });\n    return values;\n  }\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n  reset() {\n    if (this.payload) {\n      each(this.payload, (node) => node.reset());\n    }\n  }\n  _makePayload(source) {\n    if (source) {\n      const payload = new Set();\n      eachProp(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n  _addToPayload(source) {\n    if (TreeContext.dependencies && hasFluidValue(source)) {\n      TreeContext.dependencies.add(source);\n    }\n    const payload = getPayload(source);\n    if (payload) {\n      each(payload, (node) => this.add(node));\n    }\n  }\n}\n\nclass AnimatedArray extends AnimatedObject {\n  constructor(source) {\n    super(source);\n  }\n  static create(source) {\n    return new AnimatedArray(source);\n  }\n  getValue() {\n    return this.source.map((node) => node.getValue());\n  }\n  setValue(source) {\n    const payload = this.getPayload();\n    if (source.length == payload.length) {\n      return payload.some((node, i) => node.setValue(source[i]));\n    }\n    super.setValue(source.map(makeAnimated));\n    return true;\n  }\n}\nfunction makeAnimated(value) {\n  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  return nodeType.create(value);\n}\n\nfunction getAnimatedType(value) {\n  const parentNode = getAnimated(value);\n  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;\n}\n\nconst withAnimated = (Component, host) => {\n  const hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  return forwardRef((givenProps, givenRef) => {\n    const instanceRef = useRef(null);\n    const ref = hasInstance && useCallback((value) => {\n      instanceRef.current = updateRef(givenRef, value);\n    }, [givenRef]);\n    const [props, deps] = getAnimatedState(givenProps, host);\n    const forceUpdate = useForceUpdate();\n    const callback = () => {\n      const instance = instanceRef.current;\n      if (hasInstance && !instance) {\n        return;\n      }\n      const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;\n      if (didUpdate === false) {\n        forceUpdate();\n      }\n    };\n    const observer = new PropsObserver(callback, deps);\n    const observerRef = useRef();\n    useLayoutEffect(() => {\n      const lastObserver = observerRef.current;\n      observerRef.current = observer;\n      each(deps, (dep) => addFluidObserver(dep, observer));\n      if (lastObserver) {\n        each(lastObserver.deps, (dep) => removeFluidObserver(dep, lastObserver));\n        raf.cancel(lastObserver.update);\n      }\n    });\n    useEffect(callback, []);\n    useOnce(() => () => {\n      const observer2 = observerRef.current;\n      each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));\n    });\n    const usedProps = host.getComponentProps(props.getValue());\n    return /* @__PURE__ */ createElement(Component, {\n      ...usedProps,\n      ref\n    });\n  });\n};\nclass PropsObserver {\n  constructor(update, deps) {\n    this.update = update;\n    this.deps = deps;\n  }\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      raf.write(this.update);\n    }\n  }\n}\nfunction getAnimatedState(props, host) {\n  const dependencies = new Set();\n  TreeContext.dependencies = dependencies;\n  if (props.style)\n    props = {\n      ...props,\n      style: host.createAnimatedStyle(props.style)\n    };\n  props = new AnimatedObject(props);\n  TreeContext.dependencies = null;\n  return [props, dependencies];\n}\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref))\n      ref(value);\n    else\n      ref.current = value;\n  }\n  return value;\n}\n\nconst cacheKey = Symbol.for(\"AnimatedComponent\");\nconst createHost = (components, {\n  applyAnimatedValues = () => false,\n  createAnimatedStyle = (style) => new AnimatedObject(style),\n  getComponentProps = (props) => props\n} = {}) => {\n  const hostConfig = {\n    applyAnimatedValues,\n    createAnimatedStyle,\n    getComponentProps\n  };\n  const animated = (Component) => {\n    const displayName = getDisplayName(Component) || \"Anonymous\";\n    if (is.str(Component)) {\n      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n    Component.displayName = `Animated(${displayName})`;\n    return Component;\n  };\n  eachProp(components, (Component, key) => {\n    if (is.arr(components)) {\n      key = getDisplayName(Component);\n    }\n    animated[key] = animated(Component);\n  });\n  return {\n    animated\n  };\n};\nconst getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedString, AnimatedValue, createHost, getAnimated, getAnimatedType, getPayload, isAnimated, setAnimated };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}