{"ast":null,"code":"import { max, min, sum } from \"d3-array\";\nimport { justify } from \"./align.js\";\nimport constant from \"./constant.js\";\n\nfunction ascendingSourceBreadth(a, b) {\n  return ascendingBreadth(a.source, b.source) || a.index - b.index;\n}\n\nfunction ascendingTargetBreadth(a, b) {\n  return ascendingBreadth(a.target, b.target) || a.index - b.index;\n}\n\nfunction ascendingBreadth(a, b) {\n  return a.y0 - b.y0;\n}\n\nfunction value(d) {\n  return d.value;\n}\n\nfunction defaultId(d) {\n  return d.index;\n}\n\nfunction defaultNodes(graph) {\n  return graph.nodes;\n}\n\nfunction defaultLinks(graph) {\n  return graph.links;\n}\n\nfunction find(nodeById, id) {\n  const node = nodeById.get(id);\n  if (!node) throw new Error(\"missing: \" + id);\n  return node;\n}\n\nfunction computeLinkBreadths(_ref) {\n  let {\n    nodes\n  } = _ref;\n\n  for (const node of nodes) {\n    let y0 = node.y0;\n    let y1 = y0;\n\n    for (const link of node.sourceLinks) {\n      link.y0 = y0 + link.width / 2;\n      y0 += link.width;\n    }\n\n    for (const link of node.targetLinks) {\n      link.y1 = y1 + link.width / 2;\n      y1 += link.width;\n    }\n  }\n}\n\nexport default function Sankey() {\n  let x0 = 0,\n      y0 = 0,\n      x1 = 1,\n      y1 = 1; // extent\n\n  let dx = 24; // nodeWidth\n\n  let dy = 8,\n      py; // nodePadding\n\n  let id = defaultId;\n  let align = justify;\n  let sort;\n  let linkSort;\n  let nodes = defaultNodes;\n  let links = defaultLinks;\n  let iterations = 6;\n\n  function sankey() {\n    const graph = {\n      nodes: nodes.apply(null, arguments),\n      links: links.apply(null, arguments)\n    };\n    computeNodeLinks(graph);\n    computeNodeValues(graph);\n    computeNodeDepths(graph);\n    computeNodeHeights(graph);\n    computeNodeBreadths(graph);\n    computeLinkBreadths(graph);\n    return graph;\n  }\n\n  sankey.update = function (graph) {\n    computeLinkBreadths(graph);\n    return graph;\n  };\n\n  sankey.nodeId = function (_) {\n    return arguments.length ? (id = typeof _ === \"function\" ? _ : constant(_), sankey) : id;\n  };\n\n  sankey.nodeAlign = function (_) {\n    return arguments.length ? (align = typeof _ === \"function\" ? _ : constant(_), sankey) : align;\n  };\n\n  sankey.nodeSort = function (_) {\n    return arguments.length ? (sort = _, sankey) : sort;\n  };\n\n  sankey.nodeWidth = function (_) {\n    return arguments.length ? (dx = +_, sankey) : dx;\n  };\n\n  sankey.nodePadding = function (_) {\n    return arguments.length ? (dy = py = +_, sankey) : dy;\n  };\n\n  sankey.nodes = function (_) {\n    return arguments.length ? (nodes = typeof _ === \"function\" ? _ : constant(_), sankey) : nodes;\n  };\n\n  sankey.links = function (_) {\n    return arguments.length ? (links = typeof _ === \"function\" ? _ : constant(_), sankey) : links;\n  };\n\n  sankey.linkSort = function (_) {\n    return arguments.length ? (linkSort = _, sankey) : linkSort;\n  };\n\n  sankey.size = function (_) {\n    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];\n  };\n\n  sankey.extent = function (_) {\n    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];\n  };\n\n  sankey.iterations = function (_) {\n    return arguments.length ? (iterations = +_, sankey) : iterations;\n  };\n\n  function computeNodeLinks(_ref2) {\n    let {\n      nodes,\n      links\n    } = _ref2;\n\n    for (const [i, node] of nodes.entries()) {\n      node.index = i;\n      node.sourceLinks = [];\n      node.targetLinks = [];\n    }\n\n    const nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d]));\n\n    for (const [i, link] of links.entries()) {\n      link.index = i;\n      let {\n        source,\n        target\n      } = link;\n      if (typeof source !== \"object\") source = link.source = find(nodeById, source);\n      if (typeof target !== \"object\") target = link.target = find(nodeById, target);\n      source.sourceLinks.push(link);\n      target.targetLinks.push(link);\n    }\n\n    if (linkSort != null) {\n      for (const {\n        sourceLinks,\n        targetLinks\n      } of nodes) {\n        sourceLinks.sort(linkSort);\n        targetLinks.sort(linkSort);\n      }\n    }\n  }\n\n  function computeNodeValues(_ref3) {\n    let {\n      nodes\n    } = _ref3;\n\n    for (const node of nodes) {\n      node.value = node.fixedValue === undefined ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value)) : node.fixedValue;\n    }\n  }\n\n  function computeNodeDepths(_ref4) {\n    let {\n      nodes\n    } = _ref4;\n    const n = nodes.length;\n    let current = new Set(nodes);\n    let next = new Set();\n    let x = 0;\n\n    while (current.size) {\n      for (const node of current) {\n        node.depth = x;\n\n        for (const {\n          target\n        } of node.sourceLinks) {\n          next.add(target);\n        }\n      }\n\n      if (++x > n) throw new Error(\"circular link\");\n      current = next;\n      next = new Set();\n    }\n  }\n\n  function computeNodeHeights(_ref5) {\n    let {\n      nodes\n    } = _ref5;\n    const n = nodes.length;\n    let current = new Set(nodes);\n    let next = new Set();\n    let x = 0;\n\n    while (current.size) {\n      for (const node of current) {\n        node.height = x;\n\n        for (const {\n          source\n        } of node.targetLinks) {\n          next.add(source);\n        }\n      }\n\n      if (++x > n) throw new Error(\"circular link\");\n      current = next;\n      next = new Set();\n    }\n  }\n\n  function computeNodeLayers(_ref6) {\n    let {\n      nodes\n    } = _ref6;\n    const x = max(nodes, d => d.depth) + 1;\n    const kx = (x1 - x0 - dx) / (x - 1);\n    const columns = new Array(x);\n\n    for (const node of nodes) {\n      const i = Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x))));\n      node.layer = i;\n      node.x0 = x0 + i * kx;\n      node.x1 = node.x0 + dx;\n      if (columns[i]) columns[i].push(node);else columns[i] = [node];\n    }\n\n    if (sort) for (const column of columns) {\n      column.sort(sort);\n    }\n    return columns;\n  }\n\n  function initializeNodeBreadths(columns) {\n    const ky = min(columns, c => (y1 - y0 - (c.length - 1) * py) / sum(c, value));\n\n    for (const nodes of columns) {\n      let y = y0;\n\n      for (const node of nodes) {\n        node.y0 = y;\n        node.y1 = y + node.value * ky;\n        y = node.y1 + py;\n\n        for (const link of node.sourceLinks) {\n          link.width = link.value * ky;\n        }\n      }\n\n      y = (y1 - y + py) / (nodes.length + 1);\n\n      for (let i = 0; i < nodes.length; ++i) {\n        const node = nodes[i];\n        node.y0 += y * (i + 1);\n        node.y1 += y * (i + 1);\n      }\n\n      reorderLinks(nodes);\n    }\n  }\n\n  function computeNodeBreadths(graph) {\n    const columns = computeNodeLayers(graph);\n    py = Math.min(dy, (y1 - y0) / (max(columns, c => c.length) - 1));\n    initializeNodeBreadths(columns);\n\n    for (let i = 0; i < iterations; ++i) {\n      const alpha = Math.pow(0.99, i);\n      const beta = Math.max(1 - alpha, (i + 1) / iterations);\n      relaxRightToLeft(columns, alpha, beta);\n      relaxLeftToRight(columns, alpha, beta);\n    }\n  } // Reposition each node based on its incoming (target) links.\n\n\n  function relaxLeftToRight(columns, alpha, beta) {\n    for (let i = 1, n = columns.length; i < n; ++i) {\n      const column = columns[i];\n\n      for (const target of column) {\n        let y = 0;\n        let w = 0;\n\n        for (const {\n          source,\n          value\n        } of target.targetLinks) {\n          let v = value * (target.layer - source.layer);\n          y += targetTop(source, target) * v;\n          w += v;\n        }\n\n        if (!(w > 0)) continue;\n        let dy = (y / w - target.y0) * alpha;\n        target.y0 += dy;\n        target.y1 += dy;\n        reorderNodeLinks(target);\n      }\n\n      if (sort === undefined) column.sort(ascendingBreadth);\n      resolveCollisions(column, beta);\n    }\n  } // Reposition each node based on its outgoing (source) links.\n\n\n  function relaxRightToLeft(columns, alpha, beta) {\n    for (let n = columns.length, i = n - 2; i >= 0; --i) {\n      const column = columns[i];\n\n      for (const source of column) {\n        let y = 0;\n        let w = 0;\n\n        for (const {\n          target,\n          value\n        } of source.sourceLinks) {\n          let v = value * (target.layer - source.layer);\n          y += sourceTop(source, target) * v;\n          w += v;\n        }\n\n        if (!(w > 0)) continue;\n        let dy = (y / w - source.y0) * alpha;\n        source.y0 += dy;\n        source.y1 += dy;\n        reorderNodeLinks(source);\n      }\n\n      if (sort === undefined) column.sort(ascendingBreadth);\n      resolveCollisions(column, beta);\n    }\n  }\n\n  function resolveCollisions(nodes, alpha) {\n    const i = nodes.length >> 1;\n    const subject = nodes[i];\n    resolveCollisionsBottomToTop(nodes, subject.y0 - py, i - 1, alpha);\n    resolveCollisionsTopToBottom(nodes, subject.y1 + py, i + 1, alpha);\n    resolveCollisionsBottomToTop(nodes, y1, nodes.length - 1, alpha);\n    resolveCollisionsTopToBottom(nodes, y0, 0, alpha);\n  } // Push any overlapping nodes down.\n\n\n  function resolveCollisionsTopToBottom(nodes, y, i, alpha) {\n    for (; i < nodes.length; ++i) {\n      const node = nodes[i];\n      const dy = (y - node.y0) * alpha;\n      if (dy > 1e-6) node.y0 += dy, node.y1 += dy;\n      y = node.y1 + py;\n    }\n  } // Push any overlapping nodes up.\n\n\n  function resolveCollisionsBottomToTop(nodes, y, i, alpha) {\n    for (; i >= 0; --i) {\n      const node = nodes[i];\n      const dy = (node.y1 - y) * alpha;\n      if (dy > 1e-6) node.y0 -= dy, node.y1 -= dy;\n      y = node.y0 - py;\n    }\n  }\n\n  function reorderNodeLinks(_ref7) {\n    let {\n      sourceLinks,\n      targetLinks\n    } = _ref7;\n\n    if (linkSort === undefined) {\n      for (const {\n        source: {\n          sourceLinks\n        }\n      } of targetLinks) {\n        sourceLinks.sort(ascendingTargetBreadth);\n      }\n\n      for (const {\n        target: {\n          targetLinks\n        }\n      } of sourceLinks) {\n        targetLinks.sort(ascendingSourceBreadth);\n      }\n    }\n  }\n\n  function reorderLinks(nodes) {\n    if (linkSort === undefined) {\n      for (const {\n        sourceLinks,\n        targetLinks\n      } of nodes) {\n        sourceLinks.sort(ascendingTargetBreadth);\n        targetLinks.sort(ascendingSourceBreadth);\n      }\n    }\n  } // Returns the target.y0 that would produce an ideal link from source to target.\n\n\n  function targetTop(source, target) {\n    let y = source.y0 - (source.sourceLinks.length - 1) * py / 2;\n\n    for (const {\n      target: node,\n      width\n    } of source.sourceLinks) {\n      if (node === target) break;\n      y += width + py;\n    }\n\n    for (const {\n      source: node,\n      width\n    } of target.targetLinks) {\n      if (node === source) break;\n      y -= width;\n    }\n\n    return y;\n  } // Returns the source.y0 that would produce an ideal link from source to target.\n\n\n  function sourceTop(source, target) {\n    let y = target.y0 - (target.targetLinks.length - 1) * py / 2;\n\n    for (const {\n      source: node,\n      width\n    } of target.targetLinks) {\n      if (node === source) break;\n      y += width + py;\n    }\n\n    for (const {\n      target: node,\n      width\n    } of source.sourceLinks) {\n      if (node === target) break;\n      y -= width;\n    }\n\n    return y;\n  }\n\n  return sankey;\n}","map":{"version":3,"names":["max","min","sum","justify","constant","ascendingSourceBreadth","a","b","ascendingBreadth","source","index","ascendingTargetBreadth","target","y0","value","d","defaultId","defaultNodes","graph","nodes","defaultLinks","links","find","nodeById","id","node","get","Error","computeLinkBreadths","y1","link","sourceLinks","width","targetLinks","Sankey","x0","x1","dx","dy","py","align","sort","linkSort","iterations","sankey","apply","arguments","computeNodeLinks","computeNodeValues","computeNodeDepths","computeNodeHeights","computeNodeBreadths","update","nodeId","_","length","nodeAlign","nodeSort","nodeWidth","nodePadding","size","extent","i","entries","Map","map","push","fixedValue","undefined","Math","n","current","Set","next","x","depth","add","height","computeNodeLayers","kx","columns","Array","floor","call","layer","column","initializeNodeBreadths","ky","c","y","reorderLinks","alpha","pow","beta","relaxRightToLeft","relaxLeftToRight","w","v","targetTop","reorderNodeLinks","resolveCollisions","sourceTop","subject","resolveCollisionsBottomToTop","resolveCollisionsTopToBottom"],"sources":["/Users/neilrens/Desktop/stanford-finances/node_modules/d3-sankey/src/sankey.js"],"sourcesContent":["import {max, min, sum} from \"d3-array\";\nimport {justify} from \"./align.js\";\nimport constant from \"./constant.js\";\n\nfunction ascendingSourceBreadth(a, b) {\n  return ascendingBreadth(a.source, b.source) || a.index - b.index;\n}\n\nfunction ascendingTargetBreadth(a, b) {\n  return ascendingBreadth(a.target, b.target) || a.index - b.index;\n}\n\nfunction ascendingBreadth(a, b) {\n  return a.y0 - b.y0;\n}\n\nfunction value(d) {\n  return d.value;\n}\n\nfunction defaultId(d) {\n  return d.index;\n}\n\nfunction defaultNodes(graph) {\n  return graph.nodes;\n}\n\nfunction defaultLinks(graph) {\n  return graph.links;\n}\n\nfunction find(nodeById, id) {\n  const node = nodeById.get(id);\n  if (!node) throw new Error(\"missing: \" + id);\n  return node;\n}\n\nfunction computeLinkBreadths({nodes}) {\n  for (const node of nodes) {\n    let y0 = node.y0;\n    let y1 = y0;\n    for (const link of node.sourceLinks) {\n      link.y0 = y0 + link.width / 2;\n      y0 += link.width;\n    }\n    for (const link of node.targetLinks) {\n      link.y1 = y1 + link.width / 2;\n      y1 += link.width;\n    }\n  }\n}\n\nexport default function Sankey() {\n  let x0 = 0, y0 = 0, x1 = 1, y1 = 1; // extent\n  let dx = 24; // nodeWidth\n  let dy = 8, py; // nodePadding\n  let id = defaultId;\n  let align = justify;\n  let sort;\n  let linkSort;\n  let nodes = defaultNodes;\n  let links = defaultLinks;\n  let iterations = 6;\n\n  function sankey() {\n    const graph = {nodes: nodes.apply(null, arguments), links: links.apply(null, arguments)};\n    computeNodeLinks(graph);\n    computeNodeValues(graph);\n    computeNodeDepths(graph);\n    computeNodeHeights(graph);\n    computeNodeBreadths(graph);\n    computeLinkBreadths(graph);\n    return graph;\n  }\n\n  sankey.update = function(graph) {\n    computeLinkBreadths(graph);\n    return graph;\n  };\n\n  sankey.nodeId = function(_) {\n    return arguments.length ? (id = typeof _ === \"function\" ? _ : constant(_), sankey) : id;\n  };\n\n  sankey.nodeAlign = function(_) {\n    return arguments.length ? (align = typeof _ === \"function\" ? _ : constant(_), sankey) : align;\n  };\n\n  sankey.nodeSort = function(_) {\n    return arguments.length ? (sort = _, sankey) : sort;\n  };\n\n  sankey.nodeWidth = function(_) {\n    return arguments.length ? (dx = +_, sankey) : dx;\n  };\n\n  sankey.nodePadding = function(_) {\n    return arguments.length ? (dy = py = +_, sankey) : dy;\n  };\n\n  sankey.nodes = function(_) {\n    return arguments.length ? (nodes = typeof _ === \"function\" ? _ : constant(_), sankey) : nodes;\n  };\n\n  sankey.links = function(_) {\n    return arguments.length ? (links = typeof _ === \"function\" ? _ : constant(_), sankey) : links;\n  };\n\n  sankey.linkSort = function(_) {\n    return arguments.length ? (linkSort = _, sankey) : linkSort;\n  };\n\n  sankey.size = function(_) {\n    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];\n  };\n\n  sankey.extent = function(_) {\n    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];\n  };\n\n  sankey.iterations = function(_) {\n    return arguments.length ? (iterations = +_, sankey) : iterations;\n  };\n\n  function computeNodeLinks({nodes, links}) {\n    for (const [i, node] of nodes.entries()) {\n      node.index = i;\n      node.sourceLinks = [];\n      node.targetLinks = [];\n    }\n    const nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d]));\n    for (const [i, link] of links.entries()) {\n      link.index = i;\n      let {source, target} = link;\n      if (typeof source !== \"object\") source = link.source = find(nodeById, source);\n      if (typeof target !== \"object\") target = link.target = find(nodeById, target);\n      source.sourceLinks.push(link);\n      target.targetLinks.push(link);\n    }\n    if (linkSort != null) {\n      for (const {sourceLinks, targetLinks} of nodes) {\n        sourceLinks.sort(linkSort);\n        targetLinks.sort(linkSort);\n      }\n    }\n  }\n\n  function computeNodeValues({nodes}) {\n    for (const node of nodes) {\n      node.value = node.fixedValue === undefined\n          ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value))\n          : node.fixedValue;\n    }\n  }\n\n  function computeNodeDepths({nodes}) {\n    const n = nodes.length;\n    let current = new Set(nodes);\n    let next = new Set;\n    let x = 0;\n    while (current.size) {\n      for (const node of current) {\n        node.depth = x;\n        for (const {target} of node.sourceLinks) {\n          next.add(target);\n        }\n      }\n      if (++x > n) throw new Error(\"circular link\");\n      current = next;\n      next = new Set;\n    }\n  }\n\n  function computeNodeHeights({nodes}) {\n    const n = nodes.length;\n    let current = new Set(nodes);\n    let next = new Set;\n    let x = 0;\n    while (current.size) {\n      for (const node of current) {\n        node.height = x;\n        for (const {source} of node.targetLinks) {\n          next.add(source);\n        }\n      }\n      if (++x > n) throw new Error(\"circular link\");\n      current = next;\n      next = new Set;\n    }\n  }\n\n  function computeNodeLayers({nodes}) {\n    const x = max(nodes, d => d.depth) + 1;\n    const kx = (x1 - x0 - dx) / (x - 1);\n    const columns = new Array(x);\n    for (const node of nodes) {\n      const i = Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x))));\n      node.layer = i;\n      node.x0 = x0 + i * kx;\n      node.x1 = node.x0 + dx;\n      if (columns[i]) columns[i].push(node);\n      else columns[i] = [node];\n    }\n    if (sort) for (const column of columns) {\n      column.sort(sort);\n    }\n    return columns;\n  }\n\n  function initializeNodeBreadths(columns) {\n    const ky = min(columns, c => (y1 - y0 - (c.length - 1) * py) / sum(c, value));\n    for (const nodes of columns) {\n      let y = y0;\n      for (const node of nodes) {\n        node.y0 = y;\n        node.y1 = y + node.value * ky;\n        y = node.y1 + py;\n        for (const link of node.sourceLinks) {\n          link.width = link.value * ky;\n        }\n      }\n      y = (y1 - y + py) / (nodes.length + 1);\n      for (let i = 0; i < nodes.length; ++i) {\n        const node = nodes[i];\n        node.y0 += y * (i + 1);\n        node.y1 += y * (i + 1);\n      }\n      reorderLinks(nodes);\n    }\n  }\n\n  function computeNodeBreadths(graph) {\n    const columns = computeNodeLayers(graph);\n    py = Math.min(dy, (y1 - y0) / (max(columns, c => c.length) - 1));\n    initializeNodeBreadths(columns);\n    for (let i = 0; i < iterations; ++i) {\n      const alpha = Math.pow(0.99, i);\n      const beta = Math.max(1 - alpha, (i + 1) / iterations);\n      relaxRightToLeft(columns, alpha, beta);\n      relaxLeftToRight(columns, alpha, beta);\n    }\n  }\n\n  // Reposition each node based on its incoming (target) links.\n  function relaxLeftToRight(columns, alpha, beta) {\n    for (let i = 1, n = columns.length; i < n; ++i) {\n      const column = columns[i];\n      for (const target of column) {\n        let y = 0;\n        let w = 0;\n        for (const {source, value} of target.targetLinks) {\n          let v = value * (target.layer - source.layer);\n          y += targetTop(source, target) * v;\n          w += v;\n        }\n        if (!(w > 0)) continue;\n        let dy = (y / w - target.y0) * alpha;\n        target.y0 += dy;\n        target.y1 += dy;\n        reorderNodeLinks(target);\n      }\n      if (sort === undefined) column.sort(ascendingBreadth);\n      resolveCollisions(column, beta);\n    }\n  }\n\n  // Reposition each node based on its outgoing (source) links.\n  function relaxRightToLeft(columns, alpha, beta) {\n    for (let n = columns.length, i = n - 2; i >= 0; --i) {\n      const column = columns[i];\n      for (const source of column) {\n        let y = 0;\n        let w = 0;\n        for (const {target, value} of source.sourceLinks) {\n          let v = value * (target.layer - source.layer);\n          y += sourceTop(source, target) * v;\n          w += v;\n        }\n        if (!(w > 0)) continue;\n        let dy = (y / w - source.y0) * alpha;\n        source.y0 += dy;\n        source.y1 += dy;\n        reorderNodeLinks(source);\n      }\n      if (sort === undefined) column.sort(ascendingBreadth);\n      resolveCollisions(column, beta);\n    }\n  }\n\n  function resolveCollisions(nodes, alpha) {\n    const i = nodes.length >> 1;\n    const subject = nodes[i];\n    resolveCollisionsBottomToTop(nodes, subject.y0 - py, i - 1, alpha);\n    resolveCollisionsTopToBottom(nodes, subject.y1 + py, i + 1, alpha);\n    resolveCollisionsBottomToTop(nodes, y1, nodes.length - 1, alpha);\n    resolveCollisionsTopToBottom(nodes, y0, 0, alpha);\n  }\n\n  // Push any overlapping nodes down.\n  function resolveCollisionsTopToBottom(nodes, y, i, alpha) {\n    for (; i < nodes.length; ++i) {\n      const node = nodes[i];\n      const dy = (y - node.y0) * alpha;\n      if (dy > 1e-6) node.y0 += dy, node.y1 += dy;\n      y = node.y1 + py;\n    }\n  }\n\n  // Push any overlapping nodes up.\n  function resolveCollisionsBottomToTop(nodes, y, i, alpha) {\n    for (; i >= 0; --i) {\n      const node = nodes[i];\n      const dy = (node.y1 - y) * alpha;\n      if (dy > 1e-6) node.y0 -= dy, node.y1 -= dy;\n      y = node.y0 - py;\n    }\n  }\n\n  function reorderNodeLinks({sourceLinks, targetLinks}) {\n    if (linkSort === undefined) {\n      for (const {source: {sourceLinks}} of targetLinks) {\n        sourceLinks.sort(ascendingTargetBreadth);\n      }\n      for (const {target: {targetLinks}} of sourceLinks) {\n        targetLinks.sort(ascendingSourceBreadth);\n      }\n    }\n  }\n\n  function reorderLinks(nodes) {\n    if (linkSort === undefined) {\n      for (const {sourceLinks, targetLinks} of nodes) {\n        sourceLinks.sort(ascendingTargetBreadth);\n        targetLinks.sort(ascendingSourceBreadth);\n      }\n    }\n  }\n\n  // Returns the target.y0 that would produce an ideal link from source to target.\n  function targetTop(source, target) {\n    let y = source.y0 - (source.sourceLinks.length - 1) * py / 2;\n    for (const {target: node, width} of source.sourceLinks) {\n      if (node === target) break;\n      y += width + py;\n    }\n    for (const {source: node, width} of target.targetLinks) {\n      if (node === source) break;\n      y -= width;\n    }\n    return y;\n  }\n\n  // Returns the source.y0 that would produce an ideal link from source to target.\n  function sourceTop(source, target) {\n    let y = target.y0 - (target.targetLinks.length - 1) * py / 2;\n    for (const {source: node, width} of target.targetLinks) {\n      if (node === source) break;\n      y += width + py;\n    }\n    for (const {target: node, width} of source.sourceLinks) {\n      if (node === target) break;\n      y -= width;\n    }\n    return y;\n  }\n\n  return sankey;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}