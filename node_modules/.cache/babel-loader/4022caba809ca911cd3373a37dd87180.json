{"ast":null,"code":"var $get = Symbol.for('FluidValue.get');\nvar $observers = Symbol.for('FluidValue.observers');\nexport { FluidValue, hasFluidValue, getFluidValue, getFluidObservers, callFluidObserver, callFluidObservers, // Mutations\nsetFluidGetter, addFluidObserver, removeFluidObserver };\n/** Returns true if `arg` can be observed. */\n\nvar hasFluidValue = function hasFluidValue(arg) {\n  return Boolean(arg && arg[$get]);\n};\n/**\n * Get the current value.\n * If `arg` is not observable, `arg` is returned.\n */\n\n\nvar getFluidValue = function getFluidValue(arg) {\n  return arg && arg[$get] ? arg[$get]() : arg;\n};\n/** Get the current observer set. Never mutate it directly! */\n\n\nvar getFluidObservers = function getFluidObservers(target) {\n  return target[$observers] || null;\n};\n\nfunction callFluidObserver(observer, event) {\n  if (observer.eventObserved) {\n    observer.eventObserved(event);\n  } else {\n    observer(event);\n  }\n}\n\nfunction callFluidObservers(target, event) {\n  var observers = target[$observers];\n\n  if (observers) {\n    observers.forEach(function (observer) {\n      callFluidObserver(observer, event);\n    });\n  }\n}\n/**\n * Extend this class for automatic TypeScript support when passing\n * an object to a `fluids` compatible function.\n */\n\n\nvar FluidValue =\n/** @class */\nfunction () {\n  function FluidValue(get) {\n    if (!get && !(get = this.get)) {\n      throw Error('Unknown getter');\n    }\n\n    setFluidGetter(this, get);\n  }\n\n  return FluidValue;\n}();\n/** Define the getter called by `getFluidValue`. */\n\n\nvar setFluidGetter = function setFluidGetter(target, get) {\n  return setHidden(target, $get, get);\n};\n\nfunction addFluidObserver(target, observer) {\n  if (target[$get]) {\n    var observers = target[$observers];\n\n    if (!observers) {\n      setHidden(target, $observers, observers = new Set());\n    }\n\n    if (!observers.has(observer)) {\n      observers.add(observer);\n\n      if (target.observerAdded) {\n        target.observerAdded(observers.size, observer);\n      }\n    }\n  }\n\n  return observer;\n}\n\nfunction removeFluidObserver(target, observer) {\n  var observers = target[$observers];\n\n  if (observers && observers.has(observer)) {\n    var count = observers.size - 1;\n\n    if (count) {\n      observers.delete(observer);\n    } else {\n      setHidden(target, $observers, null);\n    }\n\n    if (target.observerRemoved) {\n      target.observerRemoved(count, observer);\n    }\n  }\n}\n\nvar setHidden = function setHidden(target, key, value) {\n  return Object.defineProperty(target, key, {\n    value: value,\n    writable: true,\n    configurable: true\n  });\n};","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var $get = Symbol.for('FluidValue.get');\nvar $observers = Symbol.for('FluidValue.observers');\nexport { FluidValue, hasFluidValue, getFluidValue, getFluidObservers, callFluidObserver, callFluidObservers, \n// Mutations\nsetFluidGetter, addFluidObserver, removeFluidObserver, };\n/** Returns true if `arg` can be observed. */\nvar hasFluidValue = function (arg) { return Boolean(arg && arg[$get]); };\n/**\n * Get the current value.\n * If `arg` is not observable, `arg` is returned.\n */\nvar getFluidValue = function (arg) {\n    return arg && arg[$get] ? arg[$get]() : arg;\n};\n/** Get the current observer set. Never mutate it directly! */\nvar getFluidObservers = function (target) {\n    return target[$observers] || null;\n};\nfunction callFluidObserver(observer, event) {\n    if (observer.eventObserved) {\n        observer.eventObserved(event);\n    }\n    else {\n        observer(event);\n    }\n}\nfunction callFluidObservers(target, event) {\n    var observers = target[$observers];\n    if (observers) {\n        observers.forEach(function (observer) {\n            callFluidObserver(observer, event);\n        });\n    }\n}\n/**\n * Extend this class for automatic TypeScript support when passing\n * an object to a `fluids` compatible function.\n */\nvar FluidValue = /** @class */ (function () {\n    function FluidValue(get) {\n        if (!get && !(get = this.get)) {\n            throw Error('Unknown getter');\n        }\n        setFluidGetter(this, get);\n    }\n    return FluidValue;\n}());\n/** Define the getter called by `getFluidValue`. */\nvar setFluidGetter = function (target, get) {\n    return setHidden(target, $get, get);\n};\nfunction addFluidObserver(target, observer) {\n    if (target[$get]) {\n        var observers = target[$observers];\n        if (!observers) {\n            setHidden(target, $observers, (observers = new Set()));\n        }\n        if (!observers.has(observer)) {\n            observers.add(observer);\n            if (target.observerAdded) {\n                target.observerAdded(observers.size, observer);\n            }\n        }\n    }\n    return observer;\n}\nfunction removeFluidObserver(target, observer) {\n    var observers = target[$observers];\n    if (observers && observers.has(observer)) {\n        var count = observers.size - 1;\n        if (count) {\n            observers.delete(observer);\n        }\n        else {\n            setHidden(target, $observers, null);\n        }\n        if (target.observerRemoved) {\n            target.observerRemoved(count, observer);\n        }\n    }\n}\nvar setHidden = function (target, key, value) {\n    return Object.defineProperty(target, key, {\n        value: value,\n        writable: true,\n        configurable: true,\n    });\n};\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}